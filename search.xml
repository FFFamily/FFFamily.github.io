<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从输入URL到结果返回</title>
    <url>/2021/10/21/%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/</url>
    <content><![CDATA[<h1 id="从输入URL到结果返回"><a href="#从输入URL到结果返回" class="headerlink" title="从输入URL到结果返回"></a>从输入URL到结果返回</h1><ul>
<li>涉及网络协议特别是TCP协议和HTTP协议，DNS解析等等知识点贯穿</li>
</ul>
<a id="more"></a>

<h2 id="一，输入URL"><a href="#一，输入URL" class="headerlink" title="一，输入URL"></a>一，输入URL</h2><p>首先是理解URL，了解其组成</p>
<p>可以把URL分割成几个部分：协议、网络地址、资源路径</p>
<blockquote>
<p><strong>传送协议</strong>： URL包含协议部分，是浏览器和www万维网之间的沟通方式，它会告诉浏览器正确在网路上找到资源位置</p>
<p>最常见的网络传输协议的是HTTP协议（超文本传输协议）（ https则是进行加密的网络传输）；其他也还有ftp 、file、 https、mailto 、git 等。还有自定义的协议（私有协议），例如tencent。不同协议有不同的通讯内容格式。</p>
<p><strong>网络地址</strong>： 指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；</p>
<p><strong>资源路径</strong>： 指示从服务器上获取哪一项资源。</p>
</blockquote>
<p>例如：  <a href="http://www.tutu.com/a" target="_blank" rel="noopener">http://www.tutu.com/a</a></p>
<ul>
<li>协议部分：http</li>
<li>网络地址：<a href="http://www.tutu.com" target="_blank" rel="noopener">www.tutu.com</a></li>
<li>资源路径：/a</li>
</ul>
<h2 id="二，URL解析"><a href="#二，URL解析" class="headerlink" title="二，URL解析"></a>二，URL解析</h2><p>我们输入的其实是域名，不是真正的地址，所以需要有解析的操作，解析成真实的地址，也就是IP地址</p>
<blockquote>
<p><strong>IP 地址</strong>：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址。</p>
<p><strong>域名 DN（domain name ）</strong>：域名是为了识别主机名称和组织机构名称的一种具有分层的名称。 IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输错，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址</p>
<p><strong>计算机域名系统 DNS （ Domain Name System or Domain Name Service）</strong></p>
<p>它是由域名解析器和域名服务器组成的。 域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。 </p>
<p>每个域名都对应一个或多个提供相同服务的服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</p>
</blockquote>
<p>具体是怎么解析呢？</p>
<p>首先是 查询浏览器的DNS缓存，看看以前访问过没</p>
<p>再查询 系统中的DNS缓存，维护一张域名与IP地址对应表</p>
<p>再去看本机的HOST文件，里面有 ip 与 域名的映射</p>
<p>接着就会去查询DNS本地的缓存，没有则会把域名发送给本地区域服务器，看能不能找到，找不得则发起一个==迭代的DNS请求==</p>
<p>这里就涉及一个==DNS的迭代查询和递归查询==</p>
<blockquote>
<p><strong>递归查询</strong>：客户端与服务器之间属于递归查询，即当客户机想DNS服务器发出请求后，若DNS服务器本身不能解析，会向另一个DNS服务器发出查询请求，最后将结果转交给客户端的过程。 服务器必须回答目标IP与域名的映射关系。</p>
<p><strong>迭代查询</strong>：DNS服务器之间属于迭代查询。服务器接收到一次迭代查询回复一次结果，这个结果不一定死目标IP与域名的映射关系，也可以是其他DNS服务器的地址。</p>
</blockquote>
<h2 id="三，请求"><a href="#三，请求" class="headerlink" title="三，请求"></a>三，请求</h2><p>知道ip地址之后，就需要请求访问了</p>
<p>由于TCP/IP模型分四层，所以在发送数据时，每层都要对其进行封装</p>
<blockquote>
<p>接收端则反之一步步解除封装，最终拿到HTTP数据</p>
</blockquote>
<p>应用层 = 》 HTTP数据</p>
<p>传输层 = 》TCP 首部</p>
<p>网络层 = 》 IP首部</p>
<p>链路层 = 》以太网首部</p>
<p>这里涉及TCP头部封装后的数据报文格式如下</p>
<blockquote>
<p>这里也涉及</p>
<p><strong>TCP怎么保证通讯的可靠机制的？</strong></p>
</blockquote>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/TCP%E5%A4%B4%E9%83%A8.png" alt></p>
<p>解读头部</p>
<ul>
<li>源端口：源端口的作用是标识==报文的发送地址==【2字节】</li>
<li>目的端口：指明==接收方==的==应用程序端口==【2字节】</li>
</ul>
<blockquote>
<p>TCP报头中的 源端口号 和 目的端口号 同 IP数据报 中的 源IP 与 目的IP <strong>唯一确定</strong>一条TCP连接</p>
</blockquote>
<ul>
<li>序号：是TCP==可靠传输的关键部分==【4字节】<ul>
<li>首部中的序列号字段是指本报文字段所发送的数据的第一个字节的序号</li>
<li>比如：一个报文的序号字段为301，携带的数据有100，也就是说最后一个报文的序号为400，显然下一个报文的序号得从401开始</li>
<li>这个字段的名称也称为“报文段序号”</li>
</ul>
</li>
</ul>
<blockquote>
<p>在一个TCP连接中传送的字节流中的每一个字节都要按顺序编号，整个要传送的字节流的起始序号必须在连接建立时设置。</p>
</blockquote>
<ul>
<li>确认号：期望收到对方的下一个报文段的第一个数据自己的序号【4位】<ul>
<li>确认号只有当ACK标志为1时，才有效。比如建立连接时，SYN报文的ACK标志为0</li>
</ul>
</li>
</ul>
<blockquote>
<p>比如：</p>
<p>A收到B的字段，序号为501，数据长度为200，也就是接收了序号到700为止的数据</p>
<p>所以，A期望下一个报文序号为701，于是A将发送给B的确认报文段中把确认号置为701</p>
<p>同时</p>
<p>如果确认号=N，证明N-1千的数据都被正确接收</p>
</blockquote>
<ul>
<li>数据偏移：指出TCP报文的数据距离TCP报文段的起始处有多远【4位】<ul>
<li>实际上就是指出TCP报文段的首部长度</li>
<li>因为首部有长度不确定的选项字段，因此数据偏移字段是必要的</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据偏移为4位，能表示到15，也就是最大值为60字节，也就是TCP首部的最大长度，选项长度不能超过40字节《计算机网络 第7版》</p>
</blockquote>
<ul>
<li><p>保留：保留今后使用，但<strong>目前应都位0</strong>【6位】</p>
</li>
<li><p>控制位：用来说明本报文段的性质 =》URG、ACK、PSH、RST、SYN、FIN</p>
<ul>
<li>URG 紧急：当URG=1时，表明紧急指针字段有效。告诉系统<strong>此报文段中有紧急数据</strong></li>
<li>ACK  确认：<strong>当ACK=1时，确认号字段才有效，ACK=0，确认号无效</strong>。TCP规定，在连接建立后所有报文的传输都必须把ACK置1</li>
<li>PSH 推送 ：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1，接收方收到PSH=1的消息时，会尽快的交付接收应用程序，而不是等到整个缓存都填满了后再交付、</li>
</ul>
<blockquote>
<p>很少使用推送</p>
</blockquote>
<ul>
<li>RST 复位：当RST=1，表明TCP连接中出现严重差错，<strong>必须释放连接，然后再重新建立连接</strong></li>
<li>SYN 同步：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1</li>
<li>FIN：终止，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放</li>
</ul>
</li>
<li><p>窗口：<strong>滑动窗口</strong>大小，用来告知发送端<strong>接受端的缓存大小</strong>，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bits字段，因而窗口大小最大为65535。窗口值告诉对方，从本报文的段首部中的确认号算起，接收方目前允许对方发送的数据量。之所以有这个限制，是应为接收方的数据缓存空间是有限的。</p>
<ul>
<li>总之，窗口值作为接收方让发送端设置其发送窗口的依据</li>
</ul>
</li>
<li><p>校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证</p>
</li>
<li><p>紧急指针：只有当 <strong>URG 标志置 1 时紧急指针才有效</strong>。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</p>
<ul>
<li>值得注意的是，窗口值为0也可以发送紧急数据</li>
</ul>
</li>
<li><p><strong>选项和填充</strong>：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，==以保证TCP头是32的整数倍==</p>
</li>
<li><p>数据部分： TCP 报文段中的数据部分是可选的。<strong>在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部</strong>。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段</p>
</li>
</ul>
<p>要发送的内容准备好了，现在可以连接了</p>
<h3 id="1，TCP连接"><a href="#1，TCP连接" class="headerlink" title="1，TCP连接"></a>1，TCP连接</h3><p>要想请求资源，HTTP协议首先是要求建立连接，也就是TCP的三次握手，需要在客户和服务端之间交换三个TCP报文段</p>
<p>第一次握手：客户端首先胡创建==传输控制模块TCB== ，然后发送<code>SYN=1，初始序号：seq=X</code>的数据包给服务端，此时，客户端进入<code>SYN-SENT（同步已发送）</code>状态</p>
<blockquote>
<p>TCP规定。SYN数据报不能携带数据，但是消耗一个序号</p>
</blockquote>
<p>第二次握手：服务端收到请求报文后，如果同意连接，则向客户端发送给确认报文<code>SYN=1,ACK=1，确认号：ack=X+1</code>的数据包，同时为自己选择一个初始序号<code>seq=Y</code>，发送之后服务端进入<code>SYN-RCVD（同步收到）</code>状态</p>
<blockquote>
<p>这个报文也不能携带数据，也消耗一个序号</p>
</blockquote>
<p>第三次握手：客户端收到确认后，也要给服务端确认。客户端返回<code>ACK=Y+1，确认号：ack=Y+1</code>数据包，序号为<code>X+1</code>，这个时候客户端进入<code>ESTABLISHED</code>状态,此时，TCP连接以及建立，当服务端收到确认后，也进入<code>ESTABLISHED</code>状态</p>
<blockquote>
<p>TCP规定。ACK报文可以携带数据，但是如果不携带数据则不消耗序号，也就是说下一个序号还是<code>X+1</code></p>
</blockquote>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/3%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt></p>
<p>额外注意</p>
<p>（1）服务端第一次接收客户端的SYN报文时，返回的报文可以拆分成2个，先是<code>ACK=1,ack=x+1</code>，再是<code>SYN=1,seq=Y</code>，这样也就是 “4次握手”</p>
<p>（2）<strong>握手过程中传送的包里不包含数据</strong>，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>提问</p>
<p><strong>为什么不是两次握手呢？</strong></p>
<blockquote>
<p>明明服务端已经接收了请求，并且发送了确认报文以及SYN同步报文，为什么这个时候还不能发消息呢？</p>
</blockquote>
<p>这主要是为了防止已经失效的连接请求报文段突然又传送到了服务端，而产生错误 –《计算机网络 谢希仁》</p>
<p>为了解决“网络中存在延迟的重复分组”的问题  –《计算机网络》 </p>
<blockquote>
<p>这是为了<strong>避免服务器建立无用连接</strong>（客户端服务器建立连接后，却不传输数据）</p>
<p>如果只进行两次握手，如果客户端向服务器第一次发送的建立连接的请求因为某原因，<strong>兜兜转转绕了一大圈才到达服务器</strong>。这期间客户端因为未收到服务器的响应，就会再次发送连接请求，这时服务器收到了，向客户端发送连接请求后，连接便建立了。然后数据传输完毕后，释放连接。<strong>这时刚刚兜兜转转一大圈的建立连接的请求到了服务器</strong>，服务器收到后再次向客户端发送请求，发送后又建立了连接，但是建立连接后客户端没有再理会服务器，客户端与服务器之间没有传输数据，此时服务器的资源就会被浪费</p>
</blockquote>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/2%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt></p>
<p>提问</p>
<p>为什么不能是四次握手呢？</p>
<blockquote>
<p>我参考的资料中是这么解释的：<a href="https://nyimac.gitee.io/2020/12/10/URL访问服务器流程/#三、建立TCP连接" target="_blank" rel="noopener">从输入URL到浏览器显示页面的流程 - Nyima’s Blog (gitee.io)</a></p>
</blockquote>
<p><strong>因为通信不可能100%可靠</strong>（红军蓝军约定）， 而上面的三次握手已经做好了通信的准备工作， <strong>再增加握手， 并不能显著提高可靠性</strong>，所以只需要三次握手就足够了</p>
<p>这里简单介绍一下<strong>红军蓝军约定</strong></p>
<blockquote>
<p>红军和蓝军都想消灭一波敌人，但是单凭他们一个军队的力量都不足以消灭这波敌人，因此他们想到了一起合作，于是红军向蓝军发了一封电报，内容是约定好早上8点一起向敌军进攻，由于他们不确定蓝军是否一定能收到电报, 所以只有收到蓝军的回复之后才会进行进攻，而蓝军也是同样的想法，因为他们不确定红军一定能收到自己的回复而在约定好的时间发动进攻，所以他们只有收到红军的回复后才发动进攻….</p>
<p>问怎样才能保证这次战役一定胜利呢？答案是不可能的，因为<strong>双方都对于自己发出的消息对方是否一定接收得到存在质疑</strong>，所以，这样的通信将一直进行下去，结果将是使胜利的几率一直接近100%，但是却永远达不到100%。</p>
</blockquote>
<p>另一个简单回答</p>
<p>我们都知道，请求资源中TCP连接比较消耗资源，按道理次数应该更少，避免浪费</p>
<p><strong>如果四次，那么就造成了浪费，因为在三次结束之后，就已经可以保证A可以给B发信息，A可以收到B的信息； B可以给A发信息，B可以收到A的信息</strong></p>
<h3 id="2，HTTP请求"><a href="#2，HTTP请求" class="headerlink" title="2，HTTP请求"></a>2，HTTP请求</h3><p>在建立好连接之后，就可以发送HTTP请求了</p>
<blockquote>
<p>HTTP超文本协议：在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则。这些格式和规定就是超文本传输协议 HTTP</p>
</blockquote>
<p>请求报文结构如下</p>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt></p>
<blockquote>
<p>有人提到过这一步下还有一个查询MAC地址的操作，即，ARP协议</p>
</blockquote>
<p>我们知道，网络层使用的IP地址，但是在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址</p>
<p>ARP协议的作用，就是为了从网络层使用的IP地址，解析出在数据链路层使用的硬件地址</p>
<p>那么问题来了：为什么不直接使用MAC地址，而是使用抽象的IP？</p>
<blockquote>
<p>全世界有着各种各样的网络，他们使用不用的硬件技术。要想使得这些异构网络能互相通信，就必须进行非常复杂的硬件地址转换工作，因此由用户主机来完成这样的事是不可能的。但是IP编址就不一样了，连接互联网的主机都有一个唯一的IP，他们的通信非常简单。而调用ARP的复杂过程由计算机软件自动完成，用户来说不可见</p>
<p>《计算机网络 第7版》</p>
</blockquote>
<p>以上，都是属于计算机网络层面的知识</p>
<h3 id="3，服务器处理请求"><a href="#3，服务器处理请求" class="headerlink" title="3，服务器处理请求"></a>3，服务器处理请求</h3><p>服务器端收到请求后的由web服务器（准确说应该是http服务器）处理请求</p>
<p>web服务器解析用户请求，知道了需 要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</p>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82.png" alt></p>
<blockquote>
<p>我想，很多时候都是使用的TomCat作为web服务器</p>
<p>或者：Apache、Nginx、LLS</p>
</blockquote>
<p>他们会接收请求，并且将其投送到特定的应用</p>
<p>以常用的<code>Spring Web</code>为例</p>
<p>Spring MVC 中的 DispatcherServlet 充当了 Web 应用中的 Serlvet，负责将任务分配给对应的Controller，并将最终视图返回给 Web 容器</p>
<blockquote>
<p>这里就不涉及MVC的处理请求过程了</p>
</blockquote>
<h3 id="4，服务器响应请求"><a href="#4，服务器响应请求" class="headerlink" title="4，服务器响应请求"></a>4，服务器响应请求</h3><p>服务器处理完请求后，就会发送响应结果</p>
<p><img src="../images/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E/%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt></p>
<p>同时附带对应的状态码</p>
<h2 id="四，关闭"><a href="#四，关闭" class="headerlink" title="四，关闭"></a>四，关闭</h2><h3 id="1，关闭TCP连接"><a href="#1，关闭TCP连接" class="headerlink" title="1，关闭TCP连接"></a>1，关闭TCP连接</h3><p>关闭TCP连接，也就是所谓的四次挥手</p>
<p>关闭之前，先阐述两者的状态，都是处于 <code>ESTABLISHED</code>状态</p>
<p>第一次挥手：客户端发送 <code>FIN = 1,seq = u</code>的连接释放报文段，此后客户端停止发送数据，主动关闭TCP连接。并进入<code>FIN-WAIT-1（终止等待1）状态</code>    </p>
<blockquote>
<p>在FIN报文之前发送出去的数据，如果没有收到对应的ack确认报文，客户端依然会重发这些数据</p>
<p>seq=u：u等于前面已经传送过来的数据的最后一个字节的序号加1</p>
<p>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号</p>
</blockquote>
<p>第二次挥手：服务器收到<code>连接释放FIN报文</code>后，发送一个  <code>ACK = 1</code>给对方并且带上自己的序列号<code>seq = v</code>。此时，<strong>服务端就进入了CLOSE-WAIT</strong>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，<strong>但是服务器若发送数据，客户端依然要接受</strong>。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间</p>
<p>客户端收到后，进入<strong>FIN-WAIT-2</strong>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）</p>
<p>第三次挥手：在服务器器已经没有消息发送给客户端时，这个时候就会同时TCP释放连接。服务器必须发送<code>FIN=1释放报文</code>，以及确认号必须是上次发送过的确认号<code>ack=u+1</code>用来关闭服务器到客户端的数据传送，也就是通知客户端，可以真正地释放连接了。由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，<strong>服务器就进入了LAST-ACK</strong>（最后确认）状态，等待客户端的确认</p>
<p>第四次挥手：客户端收到消息后，必须发送确认报文，ACK=1，确认号ack= w+1，自己的序号为 seq = u+1（因为上一个FIN报文是u），客户端进入<code>TIME-WAIT(时间等待)状态</code>。</p>
<p>此时，服务端收到客户端的确认报文，就会进入<code>CLOSE</code> 状态，撤销TCB后，就结束了这次的TCP连接</p>
<p>但是，此时TCP连接没有断开，客户端<strong>必须经过时间等待计时器（Time-Wait timer）设置的时间2MSL后</strong>，且客户端撤销相应的TCB后，才进入CLOSED状态，也就是结束了此次TCP连接</p>
<blockquote>
<p>时间MSL叫做最长报文寿命（Maximum Segment Lifetime），RFC 793建议是设置为2分钟，报文在网络上存在的最长时间，超过这个时间报文将被丢弃</p>
<p>TCP允许不同的实现可以根据具体情况使用更小的MSL值</p>
<p>所以 2MSL 就是 4分钟，4分钟后，客户端才会进入 CLOSE 状态</p>
</blockquote>
<p>提问</p>
<p><strong>为什么必须要等待2MSL呢？</strong></p>
<blockquote>
<p>一，<strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失。服务器在发送 ACK-FIN 报文后，一定时间后依旧没有收到确认报文，服务器就会超时重传这个 ACK-FIN 报文，如果客户端在这个2MSL时间内收到了这个重传的ACK-FIN请求报文。这时就重传一次确认，重新启动2MSL计时器。最后，都进入 CLOSE 状态</p>
<p>如果不等这个2MSL，发送 ACK 报文之后，就释放了。那么就有可能收不到 重传的 ACK-FIN 报文，也就不会发送确认报文，这样服务器就进入不了 CLOSE 状态</p>
<p>二，防止类似与三次握手中提到了的<strong>已经失效的连接请求报文段</strong>出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以<strong>使本连接持续的时间内所产生的所有报文段都从网络中消失</strong>（最长生存MSL）。<strong>这样新的连接中不会出现旧连接的请求报文</strong></p>
</blockquote>
<h2 id="五，浏览器加载"><a href="#五，浏览器加载" class="headerlink" title="五，浏览器加载"></a>五，浏览器加载</h2><p>这一步就是浏览器的加载，解析，渲染</p>
<ul>
<li>解析html，生成dom树</li>
<li>解析css，生成cssom树</li>
<li>将dom树和cssom树合并，生成渲染树</li>
<li>遍历渲染树，开始布局和计算</li>
<li>绘制渲染树，显示到屏幕</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>双亲委派机制</title>
    <url>/2021/10/18/%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><ul>
<li>什么是双亲委派机制？其作用是什么？</li>
<li>双亲委派机制的过程？</li>
<li>如何破坏双亲委派机制？</li>
</ul>
<a id="more"></a>


<h2 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h2><p>双亲委派机制指当夹杂器需要加载某一个特定类时，不是立刻由自己加载，而是把这个任务委托给父加载器完成，如果父加载器上还有父加载器，就再委托给上层加载器，直到启动类加载器，如果启动类加载器加载不成功，就要往下返回给拓展类加载器，一直往下。这中间只要有一个类加载器加载成功，就返回成功。</p>
<h2 id="双亲委派机制有什么用"><a href="#双亲委派机制有什么用" class="headerlink" title="双亲委派机制有什么用"></a>双亲委派机制有什么用</h2><ul>
<li>避免重复加载类</li>
<li>保护程序安全，防止核心API被篡改</li>
</ul>
<h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h2><p>从源码我们看到，在ClassLoader的loadClass()方法实现类具体的双亲委派逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 查询是否加载过这个类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有被加载过</span></span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 传给上层加载器，将加载任务委派</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果从非null父类装入器中找不到类，则引发ClassNotFoundException</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 委派给父类加载后发现，还是没有加载出来</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果仍然找不到，则调用自己的findClass以查找该类。</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// 这是定义类装入器；记录统计数据</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何破坏双亲委派机制"><a href="#如何破坏双亲委派机制" class="headerlink" title="如何破坏双亲委派机制"></a>如何破坏双亲委派机制</h2><p>就我所了解的</p>
<ul>
<li>自定义ClassLoader，重写 LoadClass方法</li>
</ul>
<blockquote>
<p>由上面的加载方法也可以看出，双亲委派机制是在LoadClass方法中完成的，那么可想而知，不用他原有的逻<br>辑，这样不就可以破坏双亲委派了吗？在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
        <category>源码</category>
      </categories>
  </entry>
  <entry>
    <title>栈实现队列</title>
    <url>/2021/10/18/%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="使用栈实现队列"><a href="#使用栈实现队列" class="headerlink" title="使用栈实现队列"></a>使用栈实现队列</h1><ul>
<li>简单实现<a id="more"></a>

</li>
</ul>
<p>实现的核心在于</p>
<ul>
<li>一个栈管入队列</li>
<li>一个栈管出队列，如果出队列有值，直接出栈，没值则从入队列去“借”，再出栈</li>
</ul>
<p>上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剑指 Offer 09. 用两个栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 涂涂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2021/10/18 13:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> 用两个栈实现队列() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        last = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从尾部加入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Integer push = last.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除第一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断 出栈 有没有元素，有就直接出栈 没有就从入栈中拿</span></span><br><span class="line">        <span class="keyword">if</span>(head.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!last.isEmpty())&#123;</span><br><span class="line">                Integer pop = last.pop();</span><br><span class="line">                head.push(pop);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回删除元素</span></span><br><span class="line">        Integer delete = head.isEmpty()?-<span class="number">1</span>:head.pop();</span><br><span class="line">        <span class="keyword">return</span> delete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CQueue test = <span class="keyword">new</span> CQueue();</span><br><span class="line">        test.appendTail(<span class="number">1</span>);</span><br><span class="line">        test.appendTail(<span class="number">2</span>);</span><br><span class="line">        test.appendTail(<span class="number">4</span>);</span><br><span class="line">        test.appendTail(<span class="number">3</span>);</span><br><span class="line">        System.out.println(test.deleteHead());</span><br><span class="line">        System.out.println(test.deleteHead());</span><br><span class="line">        System.out.println(test.deleteHead());</span><br><span class="line">        System.out.println(test.deleteHead());</span><br><span class="line">        System.out.println(test.deleteHead());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ的基本使用</title>
    <url>/2021/10/10/abbitMQ%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="RabbitMQ的基本使用"><a href="#RabbitMQ的基本使用" class="headerlink" title="RabbitMQ的基本使用"></a>RabbitMQ的基本使用</h1><ul>
<li>实现RabbitMQ的3种消息模式</li>
</ul>
<a id="more"></a>

<blockquote>
<p>RabbitMQ初使用</p>
</blockquote>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="直连"><a href="#直连" class="headerlink" title="直连"></a>直连</h1><p>生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"xx.cn"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"tjj"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"tjj"</span>);</span><br><span class="line">        <span class="comment">// 设置虚拟主机</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/test"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 设置队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"hello"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">			<span class="comment">// 发送消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>,<span class="string">"hello"</span>,<span class="keyword">null</span>,<span class="string">"hello rabbit"</span>.getBytes());</span><br><span class="line">            channel.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要额外注意，无论是消费者还是生产者，对于队列的消息的设置是要一样的，不能说存的时候是持久化的，获取的时候就去获取不是持久化的</span></span><br><span class="line">channel.queueDeclare(<span class="string">"hello"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="string">'参数1'</span>:用来声明通道对应的队列</span><br><span class="line"><span class="string">'参数2'</span>:用来指定是否持久化队列，<span class="keyword">false</span>就代表不持久化，会在RabbitMq重启后删除，<span class="keyword">true</span>会持久化队列但里面的消息不会持久化。</span><br><span class="line"><span class="string">'参数3'</span>:用来指定是否独占队列</span><br><span class="line"><span class="string">'参数4'</span>:用来指定是否自动删除队列，是指消费者完全与队列断开连接后，才会删除</span><br><span class="line"><span class="string">'参数5'</span>:对队列的额外配置  </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果需要同时保留队列中的消息，那么需要在发送消息的时候进行设置</span></span><br><span class="line"><span class="comment">// 将null 替换为 MessageProperties.PERSISTENT_TEXT_PLAIN</span></span><br><span class="line"><span class="comment">// 这样发送的消息同样就会被持久化</span></span><br><span class="line">channel.basicPublish(<span class="string">""</span>,<span class="string">"hello"</span>, <span class="keyword">null</span>,<span class="string">"hello rabbitmq"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">"xx.cn"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"tjj"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"tjj"</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/test"</span>);</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = factory.newConnection();</span><br><span class="line">            Channel channel = connection.createChannel();</span><br><span class="line">            <span class="comment">// 监听的队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">"hello"</span>,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 接收消息</span></span><br><span class="line">            channel.basicConsume(<span class="string">"hello"</span>,<span class="keyword">true</span>,<span class="keyword">new</span> DefaultConsumer(channel)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"消费者1："</span>+<span class="keyword">new</span> String(body));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"消费者1 启动成功"</span>);</span><br><span class="line">        <span class="comment">// 这里不需要去关闭，而是需要消费者一直去监听生产者的消息</span></span><br><span class="line">        <span class="comment">// 这里关闭会导致消息来不及回调，就已经被close了</span></span><br><span class="line">        <span class="comment">//channel.close();</span></span><br><span class="line">        <span class="comment">//connection.close();</span></span><br></pre></td></tr></table></figure>

<h1 id="任务模型"><a href="#任务模型" class="headerlink" title="任务模型"></a>任务模型</h1><p>生产者都相同，只是发送多条消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i ++)&#123;</span><br><span class="line">  hread.sleep(<span class="number">500</span>);</span><br><span class="line">  channel.basicPublish(<span class="string">""</span>,<span class="string">"hello"</span>,<span class="keyword">null</span>,(<span class="string">"hello rabbit["</span>+i+<span class="string">"]"</span>).getBytes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者也相同，只需要创建两个消费者就能完成效果<br>结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">消费者1：rabbit[0]</span><br><span class="line">消费者2：rabbit[1]</span><br><span class="line">消费者1：rabbit[2]</span><br><span class="line">消费者2：rabbit[3]</span><br><span class="line">消费者1：rabbit[4]</span><br></pre></td></tr></table></figure>

<p>默认情况下，RabbitMQ将按顺序将每个消息发送给下一个使用者。<br><br><br>平均而言，每个消费者都会收到相同数量的消息。<br><br><br>这种分发消息的方式称为循环。</p>
<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>在广播模式下，消息发送流程是这样的：</p>
<ul>
<li>可以有多个消费者</li>
<li>每个<strong>消费者有自己的queue</strong>（队列）</li>
<li>每个<strong>队列都要绑定到Exchange</strong>（交换机）</li>
<li><strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li>
<li>交换机把消息发送给绑定过的所有队列</li>
<li>队列的消费者都能拿到消息。实现一条消息被多个消费者消费<br>
<br>
生产者变化的地方在需要配置交换机
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"test"</span>,<span class="string">"fanout"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda的使用</title>
    <url>/2021/01/03/ambda%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Lambda的基本使用"><a href="#Lambda的基本使用" class="headerlink" title="Lambda的基本使用"></a>Lambda的基本使用</h1><ul>
<li>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）</li>
</ul>
<a id="more"></a>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="具体测试实现"><a href="#具体测试实现" class="headerlink" title="具体测试实现"></a>具体测试实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambda</span>表达式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Calculator calculator = (<span class="keyword">int</span> a , <span class="keyword">int</span> b) -&gt; a+b;</span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>lambda 表达式只能引用标记了 final 的外层局部变量，这就是不能在 lambda 内部修改定义在域外的局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambda</span>表达式 </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span>  String str = <span class="string">"lambda"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Change change = (message) -&gt; System.out.println(str+message);</span><br><span class="line">        change.change(<span class="string">" hello!"</span>); <span class="comment">// lambda hello!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Change</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果修改域外变量<br>就会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambda</span>表达式 </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	String str1 = <span class="string">"lambda"</span>;</span><br><span class="line">        <span class="comment">// 编译器直接提示</span></span><br><span class="line">        <span class="comment">// Variable used in lambda expression should be final or effectively final</span></span><br><span class="line">        Change change2 = (message) -&gt; str1 += message;</span><br><span class="line">        change2.change(<span class="string">" hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Change</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<hr>
<p>附带一提<br><br><br>通常是在接口上声明<br>@FunctionalInterface，表名这个接口使用lambda表达式<br><br></p>
]]></content>
  </entry>
  <entry>
    <title>2020年度报告</title>
    <url>/2020/11/30/2020%E5%B9%B4%E5%BA%A6%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="个人2020年年度报告"><a href="#个人2020年年度报告" class="headerlink" title="个人2020年年度报告"></a><center>个人2020年年度报告</center></h1><a id="more"></a>
<blockquote>
<p>2020年包括大二的下学期和大三的上学期，中间穿插一个暑假</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又是一年，去年的2019年年度报告还记得，就已经到了第二年–2020年。不得不说时间过的是真的很快，转眼间，自己也是个要临近毕业的人了，回想自己的2020年，也有收获，也有欠缺，发现了自己的毛病，也改正了很多毛病，但，依旧有缺陷。努力的人还在努力，该奋斗的还是要奋斗，不能因为自己的学历而贬低自己，不能因为别人的强大而放弃自己。</p>
<p>写下今年的报告，依旧，展望未来，看好自己。</p>
<p>总结如下：</p>
<h2 id="迷迷糊糊的一年"><a href="#迷迷糊糊的一年" class="headerlink" title="迷迷糊糊的一年"></a><center>迷迷糊糊的一年</center></h2><p>今年2020，是个不安静的一年，全球的疫情，让每个人不得不安安静静的呆在家里，有人会说，那还不好，可以安安静静的呆在家里学习，真的是那样吗，我倒是更觉得家里事情更多，而且，家里最大的敌人，就是学习的枯燥了，一个人，一个桌子，每天都是那样的，唯一的一点乐趣的就是自己通过学习做出了一些东西出来，但，那也只是一点点的小火花罢了，并不能长久的点燃我，也有可能是自己的原因吧，总之，在这上半年里，自己就这样迷迷糊糊的度过了，不知道自己的一个规划，只知道学了这个学那个，这，也是今年蛮后悔的事情了。</p>
<h2 id="累且快乐着"><a href="#累且快乐着" class="headerlink" title="累且快乐着"></a><center>累且快乐着</center></h2><p>今年的学习，虽然没有完美的完成2019年的任务，但是也大部分完成了，每天脑子里想着今天学什么，这个东西应该学多久，学完了之后怎么复习，学习完了又去学什么。这样的日子，高三也经历过。该来的努力始终会来，高中的放荡不厌，得来是现在现实给你的压力，以前错过了，就不能再去放弃。虽然学习是个很累的事，但，学习中我也快乐着，终于学完了一个知识，终于能在自己的项目里使用，这也是学东西能给我的唯一的一份快乐了，能在学习中找到自己的一份快乐，是个不容易的事情。</p>
<h2 id="该死的学车"><a href="#该死的学车" class="headerlink" title="该死的学车"></a><center>该死的学车</center></h2><p>为了学车跑去长沙租个房子，结果教练人太多，每个人3天才能练练一次…我不想说了，恨死了</p>
<h2 id="有干劲的下半年"><a href="#有干劲的下半年" class="headerlink" title="有干劲的下半年"></a><center>有干劲的下半年</center></h2><p>学校里组织了一个卓越班，纸老虎的检验考试让我顺利的进去了，发现，学校里还是有着一群喜欢学习的学生，开心着也害怕着。我认识了几个很厉害的人，算法牛逼的，操作系统牛逼的，编程牛逼的，再看看我，假胖子一个，真的很想苦笑。笑一笑自己的无知。但，这同样也是动力，我会好好的努力，会成为他们之中的学霸。</p>
<h2 id="获得的技能"><a href="#获得的技能" class="headerlink" title="获得的技能"></a>获得的技能</h2><ol>
<li>Spring</li>
<li>Mybatis</li>
<li>SpringMvc</li>
<li>SVN</li>
<li>SpringBoot</li>
<li>JVM 小部分</li>
<li>Nginx</li>
<li>Linux</li>
<li>SpringCloud</li>
<li>Vue 小部分</li>
<li>Mysql 优化相关</li>
<li>Mybatis-Plus</li>
<li>Dubbo</li>
<li>数据结构和算法</li>
</ol>
<h2 id="仰望2021"><a href="#仰望2021" class="headerlink" title="仰望2021"></a><center>仰望2021</center></h2><h3 id="对自己的要求"><a href="#对自己的要求" class="headerlink" title="对自己的要求"></a>对自己的要求</h3><ol>
<li>软件设计师</li>
<li>ACM</li>
<li>蓝桥杯</li>
<li>做出属于自己的项目</li>
<li>JVM</li>
<li>Vue</li>
<li>补全自己的基础</li>
<li>学会优化自己的项目</li>
<li>小组件的学习</li>
</ol>
<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ol>
<li>《深入理解JVM》</li>
<li>《高性能Mysql》</li>
<li>《并发编程实战》</li>
<li>《挑战程序设计竞赛》</li>
<li>《剑指Offer》</li>
<li>《面试指南》</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><center>总结</center></h2><p>大三学子，明年就是最后一年，必须得全方位的提升自己，扎扎实实的学好每一步，去充实这少有的一年，去奋斗那本该要奋斗的东西。</p>
<br>

<hr>
<center><font face="华文行楷" size="5">目标：大厂</font></center>]]></content>
      <categories>
        <category>年度报告</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA进阶</title>
    <url>/2020/09/20/VA%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="JAVA进阶"><a href="#JAVA进阶" class="headerlink" title="JAVA进阶"></a>JAVA进阶</h1><ul>
<li>I/0</li>
<li>JDBC</li>
<li>多线程</li>
<li>反射</li>
<li>泛型</li>
<li>集合</li>
<li>网络编程<a id="more"></a>

</li>
</ul>
<blockquote>
<p>笔记来源于黑马视频，播客，书籍，以及个人理解</p>
</blockquote>
<h2 id="I-O：输入-输出流"><a href="#I-O：输入-输出流" class="headerlink" title="I/O：输入/输出流"></a>I/O：输入/输出流</h2><p><strong>什么是IO</strong> </p>
<p>Java中I/O操作：主要是指使用 java.io 包下的内容，进行输入、输出操作</p>
<p>IO流：就是数据传输的通道</p>
<p>流：一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象</p>
<p>输入：也叫做读取数据</p>
<p>输出：也叫做作写入数据 </p>
<p><strong>分类</strong></p>
<p>根据数据的流向分为：输入流和输出流</p>
<p>​    输入流 ：把数据从 其他设备 上读取到 内存 中的流。 </p>
<p>​    输出流 ：把数据从 内存 中写出到 其他设备 上的流。</p>
<p>格局数据的类型分为：字节流和字符流</p>
<p>​    字节流 ：以字节为单位，读写数据的流。 </p>
<p>​    字符流 ：以字符为单位，读写数据的流。</p>
<p><strong>字节流和字符流的区别（知识点）</strong></p>
<p>1，字节流没有缓冲区，直接输出，字符流有缓冲区。</p>
<blockquote>
<p>也就是说字节流不需要调用close方法就已经把内容输出了，但是字符流会在调用close或者flush方法时，内容才会输出</p>
</blockquote>
<p> 2，读写单位不同</p>
<blockquote>
<p>字节流以字节（8bit）为单位，字符流以字符为单位，根据码表的不同而不同</p>
</blockquote>
<p>3，处理对象不同</p>
<blockquote>
<p>字节流能处理所有类型的数据，而字符流只能处理字符类型的数据</p>
</blockquote>
<h3 id="一，File类"><a href="#一，File类" class="headerlink" title="一，File类"></a>一，File类</h3><p>Java文件类以抽象的方式代表文件名和目录路径名。该类主要用于文件和目录的创建、文件的查找和文件的删除等</p>
<blockquote>
<p>其中有很多API方法就不做讨论</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//不会在当前目录下创建文件</span></span><br><span class="line"><span class="comment">//但是使用其他流初始化时，没有文件就会在根目录下创建这个文件</span></span><br></pre></td></tr></table></figure>



<p>输出</p>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a><strong>FileOutputStream</strong></h4><p>FileOutputStream 类是文件输出流，用于将数据写出到文件</p>
<blockquote>
<p>写入数据的原理：</p>
<p>(内存–&gt;硬盘)</p>
<p>java程序–&gt;JVM(java虚拟机)–&gt;OS(操作系统)–&gt;OS调用写数据的方法–&gt;把数据写入到文件中</p>
</blockquote>
<p>构造方法 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> ：创建文件输出流以写入由指定的File对象表示的文件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> ： 创建文件输出流以指定的名称写入文件</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据，需要标明追加数据</p>
<p><strong>笔记</strong>：（需要验证正确与否）</p>
<p>写入一个字节，在实际的文件中，显示的却是ASCLL码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file); </span><br><span class="line">fos.write(<span class="number">33</span>);<span class="comment">//写入文件的是感叹号（！）</span></span><br></pre></td></tr></table></figure>

<p>验证是正确的，写入的是对应ASCLL码的字符</p>
<h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a><strong>FileWriter</strong></h4><p>java.io.FileWriter 类是写出字符到文件的便利类</p>
<blockquote>
<p>构造时使用系统默认的字符编码和默认字节缓冲区</p>
</blockquote>
<p>构造方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter(File file) ： 创建一个新的FileWriter，给定要读取的File对象 	</span><br><span class="line"></span><br><span class="line">FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称</span><br></pre></td></tr></table></figure>





<p>输入</p>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a><strong>FileInputStream</strong></h4><p>java.io.FileInputStream 类是文件输入流，从文件中读取字节</p>
<p>构造方法 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span></span></span><br></pre></td></tr></table></figure>

<p> 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象ﬁle命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileInputStream(String name)</span><br></pre></td></tr></table></figure>

<p>通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名 </p>
<p><strong>注意：</strong></p>
<p>当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出 FileNotFoundException ，不同于输出流</p>
<p>当文件读取到结尾时返回 -1,循环结束</p>
<h4 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a><strong>FileReader</strong></h4><p>java.io.FileReader 类是读取字符文件的便利类,是一个抽象类</p>
<blockquote>
<p>构造时使用系统默认的字符编码和默认字节缓冲区</p>
</blockquote>
<p><strong>字符编码</strong>：字节与字符的对应规则</p>
<blockquote>
<p>Windows系统的中文编码默认是GBK编码表。</p>
<p>idea中UTF-8编码表</p>
</blockquote>
<p><strong>字节缓冲区</strong>：一个字节数组，用来临时存储字节数据。</p>
<p><strong>构造方法</strong> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象  </span><br><span class="line"></span><br><span class="line">FileReader(String fileName) ： 创建一个新的 FileReader 给定要读取的文件的名称</span><br></pre></td></tr></table></figure>



<h4 id="数据追加"><a href="#数据追加" class="headerlink" title="数据追加"></a><strong>数据追加</strong></h4><p>在测试的时候，每次程序运行，创建输出流对象，都会清空目标文件中的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="comment">//文件输出流以写入由指定的 File对象表示的文件。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="comment">//创建文件输出流以指定的名称写入文件。</span></span></span><br></pre></td></tr></table></figure>

<p> 这两个构造方法，参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示清空原有数据</p>
<p> 这样创建的输出流对象，就可以指定是否追加续写了</p>
<h3 id="二，字节流"><a href="#二，字节流" class="headerlink" title="二，字节流"></a>二，字节流</h3><p><strong>一切皆为字节</strong></p>
<p>一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一 样如此。所以，字节流可以传输任意文件数据。在操作流的时候，无论使用什么样的流对象，底层传输的始终为二进制数据</p>
<h4 id="字节输出流（OutputStream-）"><a href="#字节输出流（OutputStream-）" class="headerlink" title="字节输出流（OutputStream ）"></a><strong>字节输出流（OutputStream ）</strong></h4><p>java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地</p>
<p>它定义了字节输出流的基本共性功能方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此输出流并释放与此流相关联的任何系统资源 		</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> 刷新此输出流并强制任何缓冲的输出字节被写出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> 将 b.length字节从指定的字节数组写入此输出流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> ：</span></span><br><span class="line"><span class="function"><span class="comment">//从指定的字节数组写入 len字节，从偏移量oﬀ开始输出到此输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> ：将指定的字节输出流</span></span><br></pre></td></tr></table></figure>

<p><strong>写入字节数据</strong> </p>
<ol>
<li><p>写出字节： write(int b) 方法，每次可以写出一个字节数据</p>
</li>
<li><p>写出字节数组： write(byte[] b) ，每次可以写出数组中的数据</p>
</li>
<li><p>写出指定长度字节数组： write(byte[] b, int off, int len) ,每次写出从oﬀ索引开始,len个字节</p>
</li>
</ol>
<h4 id="字节输入流（InputStream）"><a href="#字节输入流（InputStream）" class="headerlink" title="字节输入流（InputStream）"></a><strong>字节输入流（InputStream）</strong></h4><p>InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中</p>
<p>它定义了字节输入 流的基本共性功能方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此输入流并释放与此流相关联的任何系统资源。   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取数据的下一个字节。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> ： 从输入流中读取一些字节数，并将它们存储到字节数组b中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>读取数据的原理(硬盘–&gt;内存)</p>
<p>​        java程序–&gt;JVM–&gt;OS–&gt;OS读取数据的方法–&gt;读取文件</p>
</blockquote>
<p><strong>笔记：</strong></p>
<p>读取多个字节时，需要一个循环的过程，因为不清楚文件中有多少字节，数组在不确定的情况下不知道能不能装的下文件中的字节，read（）方法读取到一个字节就会返回，一般需要一个循环条件，作为结束的标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2024</span>];</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">InputStream is = <span class="keyword">new</span> InputStream(file);</span><br><span class="line"><span class="keyword">while</span> ((length = is.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, length));</span><br><span class="line">&#125;</span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>read方法在读取了一个字节后，会将指针移动到下一个字节后</p>
<p>​    并且在流的末端返回-1作为结束标志</p>
<h3 id="三，字符流"><a href="#三，字符流" class="headerlink" title="三，字符流"></a>三，字符流</h3><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为 一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。</p>
<p>UTF-8：一个中文占用三字节</p>
<p>GBK:     一个中文占用2字节</p>
<h4 id="字符输入流（Reader）"><a href="#字符输入流（Reader）" class="headerlink" title="字符输入流（Reader）"></a><strong>字符输入流（Reader）</strong></h4><p>java.io.Reader 抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中</p>
<p>它定义了字符输入流的基本共性功能方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此流并释放与此流相关联的任何系统资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取一个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] a)</span> ： 从输入流中读取一些字符，并将它们存储到字符数组a中</span></span><br></pre></td></tr></table></figure>



<h4 id="字符输出流（Writer）"><a href="#字符输出流（Writer）" class="headerlink" title="字符输出流（Writer）"></a><strong>字符输出流（Writer）</strong></h4><p>java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地</p>
<p>它定义了字节 输出流的基本共性功能方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> 写入单个字符。 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> 写入字符数组。 </span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[]a, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"> 写入字符数组的某一部分,a数组的开始索引,len 写的字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">写入字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function">写入字符串的某一部分,oﬀ字符串的开始索引,len写的字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> 刷新该流的缓冲</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此流，但要先刷新它</span></span><br></pre></td></tr></table></figure>



<h3 id="四，打印流"><a href="#四，打印流" class="headerlink" title="四，打印流"></a>四，打印流</h3><p>概述</p>
<p>平时我们在控制台打印输出，是调用<code>print</code>方法和<code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code>类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<blockquote>
<p>包含   字节打印流：PrintStream    字符打印流：PrintWriter。</p>
</blockquote>
<h4 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a><strong>PrintStream</strong></h4><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintStream</span><span class="params">(String fileName)</span> ： 使用指定的文件名创建一个新的打印流，即为改变打印流向，将输出的地方转移到fileName的地方</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//例子</span></span></span><br><span class="line"><span class="function">PrintStream ps </span>= <span class="keyword">new</span> PrintStream(<span class="string">"文件地"</span>);</span><br><span class="line">System.setOut(ps);<span class="comment">//把输出语句的目的地改变为打印流的目的地</span></span><br></pre></td></tr></table></figure>

<p>其中还有很多printf和print方法，也就是说</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf()<span class="comment">//可以打印任何数据</span></span><br></pre></td></tr></table></figure>



<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>专门打印字符</p>
<p>构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span></span></span><br></pre></td></tr></table></figure>



<h3 id="五，缓冲流"><a href="#五，缓冲流" class="headerlink" title="五，缓冲流"></a>五，缓冲流</h3><p><strong>概述</strong></p>
<p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<p>字节缓冲输入流：BufferedInputStream</p>
<p>字节缓冲输出流：BufferedOutputStream</p>
<p>字符缓冲输出流：BufferedReader</p>
<p>字符缓冲输入流：BufferedWriter</p>
<p><strong>基本原理</strong></p>
<p>是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO请求次数，从而提高读写的效率。</p>
<p><strong>构造方法</strong></p>
<p><strong>字节缓冲流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span>：创建一个 新的缓冲输入流 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span>： 创建一个新的缓冲输出流</span></span><br></pre></td></tr></table></figure>

<p><strong>字符缓冲流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span>` ：创建一个 新的缓冲输入流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span>`： 创建一个新的缓冲输出流</span></span><br></pre></td></tr></table></figure>

<p>特有的方法;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader：<span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span>: 读一行文字</span></span><br><span class="line"><span class="function">BufferedWriter：<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span>: 写一行行分隔符,由系统属性定义符号</span></span><br></pre></td></tr></table></figure>





<h3 id="六，转换流"><a href="#六，转换流" class="headerlink" title="六，转换流"></a>六，转换流</h3><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a><strong>InputStreamReader</strong></h4><p><code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。</p>
<p>它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集</p>
<blockquote>
<p>转换流是字节与字符间的桥梁</p>
</blockquote>
<p>何时使用转换流？</p>
<ol>
<li>当字节和字符之间有转换动作时</li>
<li>操作的数据需要编码或解码时</li>
</ol>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 </span><br><span class="line">InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>

<h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a><strong>OutputStreamWriter</strong></h4><p><code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。</p>
<p>使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 </span><br><span class="line">OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>



<h3 id="七，递归"><a href="#七，递归" class="headerlink" title="七，递归"></a>七，递归</h3><p>递归打印多级目录 </p>
<p>分析：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。</p>
<p> 文件搜索 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索 D:\aaa 目录中的 .java 文件。</span><br><span class="line"></span><br><span class="line">String中的endWith方法，返回值为boolean</span><br><span class="line"></span><br><span class="line">file.getName().endsWith(&quot;.java&quot;)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(pathname);<span class="comment">//创建File</span></span><br><span class="line">      File[] files = file.listFiles();<span class="comment">//把当前File对象下所有的文件夹或目录</span></span><br><span class="line">      <span class="keyword">for</span> (File file1: files)&#123;</span><br><span class="line">          <span class="keyword">if</span> (file1.isFile())&#123;<span class="comment">//递归的终止条件是：当前File为文件</span></span><br><span class="line">              System.out.println(file1.getAbsolutePath());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;<span class="comment">//当前File为目录，则，打印当前File的子文件的递归目录</span></span><br><span class="line">              <span class="comment">//String s = file1.getPath();</span></span><br><span class="line">              <span class="comment">//printAllFiles(s);</span></span><br><span class="line">              <span class="comment">//printAllFiles(file1.getPath());</span></span><br><span class="line">              System.out.println(file1.getAbsolutePath());</span><br><span class="line">              printAllFiles(file1.getAbsolutePath());</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="八，序列化和反序列化"><a href="#八，序列化和反序列化" class="headerlink" title="八，序列化和反序列化"></a>八，序列化和反序列化</h3><p>代码操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name , <span class="keyword">int</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price= price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Book&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Book(<span class="string">"sb"</span>,<span class="number">22</span>));</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"e:"</span>+File.separator+<span class="string">"demoA.txt"</span>)));</span><br><span class="line"> </span><br><span class="line">Object obj=ois.readObject()</span><br></pre></td></tr></table></figure>



<h3 id="九，关闭和刷新"><a href="#九，关闭和刷新" class="headerlink" title="九，关闭和刷新"></a>九，关闭和刷新</h3><p>因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据 的。如果我们既想写出数据，又想继续使用流，就需要 flush 方法了。</p>
<p>flush ：刷新缓冲区，流对象可以继续使用。 </p>
<p>close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了</p>
<h3 id="十，Scanner"><a href="#十，Scanner" class="headerlink" title="十，Scanner"></a>十，Scanner</h3><h3 id="十，新特性"><a href="#十，新特性" class="headerlink" title="十，新特性"></a>十，新特性</h3><p>JDK9</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">try</span>(fis;fos)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>JDK7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line"> FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\1.jpg"</span>);</span><br><span class="line"> FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:\\1.jpg"</span>);)</span><br><span class="line"> &#123;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//使用字节输出流中的方法write,把读取到的字节写入到目的地的文件中</span></span><br><span class="line">                fos.write(len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="JDBC：-Java-DataBase-Connectivity"><a href="#JDBC：-Java-DataBase-Connectivity" class="headerlink" title="JDBC： Java DataBase Connectivity"></a>JDBC： Java DataBase Connectivity</h2><h3 id="一，使用"><a href="#一，使用" class="headerlink" title="一，使用"></a>一，使用</h3><p>导入jar包，根据不同版本导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql-connector-java-5.0.8-bin-jar</span><br></pre></td></tr></table></figure>

<p>注册驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure>

<p>取数据库连接对象 Connection</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection 	&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure>

<p>定义sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String sql &#x3D; &quot;update account set balance &#x3D; 500 where id &#x3D; 1&quot;;</span><br></pre></td></tr></table></figure>

<p>获取执行sql语句的对象 Statement</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Statement stmt &#x3D; conn.createStatement();</span><br></pre></td></tr></table></figure>

<p>行sql，接受返回结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int count &#x3D; stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure>

<p>处理结果，释放资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>



<h3 id="二，具体对象"><a href="#二，具体对象" class="headerlink" title="二，具体对象"></a>二，具体对象</h3><h4 id="DriverManager：驱动管理对象"><a href="#DriverManager：驱动管理对象" class="headerlink" title="DriverManager：驱动管理对象"></a>DriverManager：驱动管理对象</h4><p>1，告诉程序该使用哪一个数据库驱动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">	 &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写代码就只用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;sql5.7版本前</span><br><span class="line">Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&#x2F;&#x2F;sql5.7版本后</span><br></pre></td></tr></table></figure>

<p>2，获取数据库连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static Connection getConnection(String url, String user, String password)</span><br></pre></td></tr></table></figure>



<h4 id="Connection：数据库连接对象"><a href="#Connection：数据库连接对象" class="headerlink" title="Connection：数据库连接对象"></a>Connection：数据库连接对象</h4><p>1，获取执行sql对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Statement createStatement()</span><br><span class="line">PreparedStatement prepareStatement(String sql)</span><br></pre></td></tr></table></figure>

<p>2，管理实务</p>
<h4 id="Statement：执行sql的对象"><a href="#Statement：执行sql的对象" class="headerlink" title="Statement：执行sql的对象"></a>Statement：执行sql的对象</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. boolean execute(String sql) ：可以执行任意的sql </span><br><span class="line">2. int executeUpdate(String sql) ：执行DML语句、DDL语句</span><br><span class="line">3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句</span><br></pre></td></tr></table></figure>



<p>executeUpdate()方法的返回值：<strong>影响的行数</strong>，<strong>可以通过这个影响的行数判断DML语句是否执行成功</strong> 返回值&gt;0的则执行成功，反之，则失败</p>
<h4 id="ResultSet：结果集对象-封装查询结果"><a href="#ResultSet：结果集对象-封装查询结果" class="headerlink" title="ResultSet：结果集对象,封装查询结果"></a>ResultSet：结果集对象,封装查询结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function"><span class="comment">//游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getXxx(参数):获取数据</span><br></pre></td></tr></table></figure>

<p>Xxx：代表数据类型 </p>
<ol>
<li>int：代表列的编号,从1开始  如： getString(1) </li>
<li>String：代表列名称。 如： getDouble(“balance”)</li>
</ol>
<p>注意：resultSet的索引是从1开始的</p>
<h4 id="PreparedStatement：执行sql的对象"><a href="#PreparedStatement：执行sql的对象" class="headerlink" title="PreparedStatement：执行sql的对象"></a>PreparedStatement：执行sql的对象</h4><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题</p>
<blockquote>
<p>输入密码：a’ or ‘a’ = ‘a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">而执行的sql：select * from user where username &#x3D; &#39;fhdsjkf&#39; and password &#x3D; &#39;a&#39; or &#39;a&#39; &#x3D; &#39;a&#39; </span><br></pre></td></tr></table></figure>
</blockquote>
<p>解决：参数使用?作为占位符</p>
<p>那么定义的sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username = ? <span class="keyword">and</span> age = ?;</span><br></pre></td></tr></table></figure>

<p>而执行sql的对象就换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement preparedStatement  = Connection.prepareStatement(String sql);</span><br></pre></td></tr></table></figure>

<p>接着就是赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法： setXxx(参数1,参数2)</span><br><span class="line">	* 参数1：？的位置编号 从1 开始</span><br><span class="line">	* 参数2：？的值</span><br><span class="line"></span><br><span class="line">preparedStatement.setString(1,&quot;图图&quot;);</span><br><span class="line">preparedStatement.setInt(1,18);</span><br></pre></td></tr></table></figure>



<h3 id="三，JDBC工具类"><a href="#三，JDBC工具类" class="headerlink" title="三，JDBC工具类"></a>三，JDBC工具类</h3><p>1，需要使用jdbc.properties配置文件保存数据源信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver&#x3D;数据库驱动路径</span><br><span class="line">url&#x3D;url连接字符串</span><br><span class="line">user&#x3D;用户名</span><br><span class="line">password&#x3D;密码</span><br></pre></td></tr></table></figure>

<p>2，实现配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;</span><br><span class="line">    <span class="comment">// 使用静态代码注册驱动并给静态变量赋值</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Properties集合类</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">// 获取src路径下文件，使用ClassLoader类加载器</span></span><br><span class="line">            ClassLoader classLoader = JDBCUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">            <span class="comment">// URL定位了文件的绝对路径</span></span><br><span class="line">            URL res = classLoader.getResource(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            <span class="comment">// 获取字符串路径</span></span><br><span class="line">            String path = res.getPath();</span><br><span class="line">            <span class="comment">// 读取文件</span></span><br><span class="line">            pro.load(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">            <span class="comment">// 给静态变量赋值</span></span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            <span class="comment">// 注册驱动</span></span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四，JDBC控制事务"><a href="#四，JDBC控制事务" class="headerlink" title="四，JDBC控制事务"></a>四，JDBC控制事务</h3><blockquote>
<p>这些东西个人认为在mysql知识点中详细归纳比较好，毕竟那些框架都对事物有良好的支持</p>
</blockquote>
<h4 id="1，开启事务"><a href="#1，开启事务" class="headerlink" title="1，开启事务"></a>1，开启事务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection.setAutoCommit(<span class="keyword">boolean</span> autoCommit);</span><br><span class="line"><span class="comment">//调用该方法设置参数为false，即开启事务</span></span><br></pre></td></tr></table></figure>

<h4 id="2，提交事务"><a href="#2，提交事务" class="headerlink" title="2，提交事务"></a>2，提交事务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection.commit();</span><br></pre></td></tr></table></figure>

<h4 id="3，回滚事务"><a href="#3，回滚事务" class="headerlink" title="3，回滚事务"></a>3，回滚事务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection.rollback();</span><br></pre></td></tr></table></figure>



<h3 id="五，数据库连接池"><a href="#五，数据库连接池" class="headerlink" title="五，数据库连接池"></a>五，数据库连接池</h3><p>其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，<strong>用户访问完之后，会将连接对象归还给容器</strong></p>
<p>实现方式</p>
<h3 id="六，SpringJDBC"><a href="#六，SpringJDBC" class="headerlink" title="六，SpringJDBC"></a>六，SpringJDBC</h3><p>1，导入jar包</p>
<p>2，创建JdbcTemplate对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依赖于数据源DataSource</span></span><br><span class="line">JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br></pre></td></tr></table></figure>

<p>3，调用JdbcTemplate的方法来完成CRUD的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">update(): 执行DML语句。增、删、改语句</span><br><span class="line"></span><br><span class="line">queryForMap():查询结果将结果集封装为map集合</span><br><span class="line"><span class="comment">//将列名作为key，将值作为value 将这条记录封装为一个map集合</span></span><br><span class="line"><span class="comment">//注意：这个方法查询的结果集长度只能是1</span></span><br><span class="line"></span><br><span class="line">queryForList():查询结果将结果集封装为list集合</span><br><span class="line"><span class="comment">//注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</span></span><br><span class="line"></span><br><span class="line">query():查询结果，将结果封装为JavaBean对象</span><br><span class="line"><span class="comment">//query的参数：RowMapper</span></span><br><span class="line"><span class="comment">//一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</span></span><br><span class="line"><span class="comment">//new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</span></span><br><span class="line"></span><br><span class="line">queryForObject()：查询结果，将结果封装为对象</span><br><span class="line"><span class="comment">//一般用于聚合函数的查询</span></span><br></pre></td></tr></table></figure>



<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><blockquote>
<p>多线程往往是java的一个性能重点，所以需要单独一个笔记讲述多线程</p>
<p>需要我查阅更多的书籍后才能对其统计知识点</p>
</blockquote>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="一，概念"><a href="#一，概念" class="headerlink" title="一，概念"></a>一，概念</h3><p><strong>对于任何一个对象，我们都能够对它的方法和属性进行调用</strong>。我们把这种<strong>动态获取对象信息和调用对象方法</strong>的功能称之为<strong>反射机制</strong>。</p>
<blockquote>
<p>我们使用的一些主流框架中反射技术应用是非常广泛的.</p>
<p>所谓反射其实是获取类的字节码文件，也就是.class文件，那么我们就可以通过Class这个对象进行获取</p>
</blockquote>
<h3 id="二，实现反射的方式"><a href="#二，实现反射的方式" class="headerlink" title="二，实现反射的方式"></a>二，实现反射的方式</h3><p>第一种：通过Object类的getClass方法 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class cla &#x3D; foo.getClass();</span><br></pre></td></tr></table></figure>

<p>第二种：通过对象实例方法获取对象 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class cla &#x3D; foo.class;</span><br></pre></td></tr></table></figure>

<p>第三种：通过Class.forName方式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class cla = Class.forName(<span class="string">"全类名"</span>);</span><br><span class="line">cla.newInstance()<span class="comment">//初始化对象，接着就是使用对象了</span></span><br></pre></td></tr></table></figure>



<h3 id="三，相关的逻辑方法"><a href="#三，相关的逻辑方法" class="headerlink" title="三，相关的逻辑方法"></a>三，相关的逻辑方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getMethod(parameterTypes)用来获取某个公有的方法的对象</span><br><span class="line">getMethods()获得该类所有公有的方法</span><br><span class="line">getDeclaredMethod(parameterTypes)获得该类某个方法</span><br><span class="line">getDeclaredMethods()获得该类所有方法</span><br></pre></td></tr></table></figure>



<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="一，概念-1"><a href="#一，概念-1" class="headerlink" title="一，概念"></a>一，概念</h3><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用</p>
<p>泛型，即“参数化类型”</p>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</p>
<h3 id="二，一个经典泛型例子"><a href="#二，一个经典泛型例子" class="headerlink" title="二，一个经典泛型例子"></a>二，一个经典泛型例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">  	System.out.printf(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序就会报错</span></span><br><span class="line"></span><br><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line"><span class="comment">//ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以就有了泛型</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="三，特性"><a href="#三，特性" class="headerlink" title="三，特性"></a>三，特性</h3><p>泛型只在编译阶段有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型</p>
</blockquote>
<p>注意</p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用instanceof操作，编译时会出错</li>
</ul>
<h3 id="四，分类"><a href="#四，分类" class="headerlink" title="四，分类"></a>四，分类</h3><h4 id="1，泛型类"><a href="#1，泛型类" class="headerlink" title="1，泛型类"></a>1，泛型类</h4><p>泛型类型用于类的定义中，被称为泛型类</p>
<blockquote>
<p>最典型的就是各种容器类，如：List、Set、Map</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2，泛型接口"><a href="#2，泛型接口" class="headerlink" title="2，泛型接口"></a>2，泛型接口</h4><p>泛型接口常被用在各种类的生产器中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现接口需要声明泛型类型，不然会报错</p>
</blockquote>
<h4 id="3，泛型方法"><a href="#3，泛型方法" class="headerlink" title="3，泛型方法"></a>3，泛型方法</h4><p>声明此方法为泛型方法：public  <T>  T </T></p>
<p>只有声明了<T>的方法才是泛型方法</T></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="五，泛型通配符"><a href="#五，泛型通配符" class="headerlink" title="五，泛型通配符"></a>五，泛型通配符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">show(gNumber);<span class="comment">//程序报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//	同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的</span></span><br><span class="line"><span class="comment">//	因此我们需要一个在逻辑上可以表示同时是Generic&lt;Integer&gt;和Generic&lt;Number&gt;父类的引用类型。由此类型通配符应运而生</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>



<h3 id="六，泛型上下边界"><a href="#六，泛型上下边界" class="headerlink" title="六，泛型上下边界"></a>六，泛型上下边界</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><blockquote>
<p>集合对于面试来讲也是一个大重点，需要额外精力去整理笔记</p>
</blockquote>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><blockquote>
<p>网络编程需要我去尝试一个聊天项目后再去整理</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA</title>
    <url>/2020/09/18/JAVA/</url>
    <content><![CDATA[<h1 id="JAVA基础知识点总结"><a href="#JAVA基础知识点总结" class="headerlink" title="JAVA基础知识点总结"></a>JAVA基础知识点总结</h1><ul>
<li>基本语法知识点</li>
</ul>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：在移植笔记的时候可能会出现错误，导致笔记混乱</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="一，两大基本数据类型"><a href="#一，两大基本数据类型" class="headerlink" title="一，两大基本数据类型"></a>一，两大基本数据类型</h3><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>类、接口类型、数组类型、枚举类型、注解类型，字符串型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A a =<span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//变量a的值为它所引用对象的地址</span></span><br></pre></td></tr></table></figure>



<h5 id="4种引用类型"><a href="#4种引用类型" class="headerlink" title="4种引用类型"></a>4种引用类型</h5><p>强引用，软引用，弱引用，虚引用</p>
<h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出<code>OutOfMemoryError</code>，不会去回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java中默认声明的就是强</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br></pre></td></tr></table></figure>



<h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><p>软引用是用来描述一些非必需但仍有用的对象</p>
<p><strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong></p>
<h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用</span></span><br><span class="line"><span class="keyword">package</span> java.lang.ref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReference</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakReference</span><span class="params">(T var1, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; var2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所得到的结果全是null，垃圾回收了对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">			WeakReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> WeakReference&lt;&gt;(buff);</span><br><span class="line">			list.add(sr);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">			Object obj = ((WeakReference) list.get(i)).get();</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</p>
<h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><blockquote>
<p>或叫做原生类、内置类型</p>
</blockquote>
<h5 id="八种基本数据类型"><a href="#八种基本数据类型" class="headerlink" title="八种基本数据类型"></a>八种基本数据类型</h5><p><code>整型</code>，<code>长整型</code>，<code>短整型</code>，<code>字节</code>，<code>单精度浮点型</code>，<code>双精度浮点型</code>，<code>字符型</code>，<code>boolean型</code></p>
<h6 id="1，整型"><a href="#1，整型" class="headerlink" title="1，整型"></a>1，整型</h6><table>
<thead>
<tr>
<th>整型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>long</code></td>
<td>8字节</td>
</tr>
<tr>
<td><code>short</code></td>
<td>2字节</td>
</tr>
<tr>
<td><code>byte</code></td>
<td>1字节</td>
</tr>
<tr>
<td><code>int</code></td>
<td>4字节</td>
</tr>
</tbody></table>
<blockquote>
<p>32位的long占4字节，64位的占8位</p>
</blockquote>
<p><strong>整数溢出问题</strong></p>
<p>int 类型在 Java 中是“有符号”的。所谓“有符号”就是有正负。</p>
<p>在计算机中用二进制表示所有的信息，这个符号的区别就看首位。</p>
<p><strong>首位如果是 0，就是正的，1 就是负的。正与负的区别也因此就在于取反加一</strong></p>
<p>所谓数值溢出就会出现这个现象</p>
<p>Java 中的 <code>int</code> 总共就 32 位，正数上限的情况首位也只能是 0，其他位都可以是 1（就是 2^31-1 的情况）。但是如果正数过大了，例如 2^31，计算机不得不把首位变成 1，并且很快就忘了这是溢出情况，把它按照正常的方式输出了，于是就成了负的，它没有办法自动处理超过溢出的情况，因为 32 位是固定的，它不能因为溢出而临时扩展到 33 位之类的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span> = <span class="number">0111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> = <span class="number">2147483647</span></span><br><span class="line"><span class="number">2</span>^<span class="number">31</span> = <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span> + <span class="number">1</span> = <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> = -<span class="number">2147483648</span></span><br></pre></td></tr></table></figure>



<p>存储数值超过了整形数值2^31-1，导致数据<strong>向上溢出</strong></p>
<p>整数数值小于了-2^31，导致数值<strong>向下溢出</strong></p>
<h6 id="2，进制"><a href="#2，进制" class="headerlink" title="2，进制"></a>2，进制</h6><p>1，十六进制，前缀为0x或者0X</p>
<p>2，八进制，前缀为0</p>
<p>3，二进制，前缀为0b或者0B</p>
<blockquote>
<p>注意</p>
<p>java没有任何无符号形式的数据类型</p>
<p><strong>无符号即为</strong> <strong>纯正数</strong>，可以理解为每个数据类型都有符号</p>
</blockquote>
<h6 id="3，浮点型"><a href="#3，浮点型" class="headerlink" title="3，浮点型"></a>3，浮点型</h6><p>知识点一：</p>
<p>浮点数值适用于无法接受舍入误差的计算中，浮点数值采用二进制系统表示，二进制无法准确的表示分数1/10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> aa =  <span class="number">12</span>/<span class="number">10</span>;</span><br><span class="line">System.out.println(aa);</span><br><span class="line"><span class="comment">//输出结果为1.0</span></span><br></pre></td></tr></table></figure>

<p>知识点二：</p>
<table>
<thead>
<tr>
<th>浮点型</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>float（单精度类型）后缀F或f</td>
<td>4字节</td>
</tr>
<tr>
<td>double（双精度类型）</td>
<td>8字节</td>
</tr>
</tbody></table>
<p>知识点三：</p>
<p>java常用的内置常数：double变量初始化为无穷大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Double.POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span></span><br><span class="line"><span class="comment">//输出：Infinity</span></span><br></pre></td></tr></table></figure>

<h6 id="4，字符型"><a href="#4，字符型" class="headerlink" title="4，字符型"></a>4，字符型</h6><p>知识点一：</p>
<p>字符型进行算数运算，运算的是ASCCL码</p>
<p><strong>可以表示为十六进制</strong>，从<code>\u0000</code>到<code>Uffff</code>（理解为可以用十六进制表示）</p>
<p>知识点二：</p>
<p>java采用Unicode编码方式，无论是中文还是英文字母，都占2字节</p>
<h6 id="5，字符串"><a href="#5，字符串" class="headerlink" title="5，字符串,"></a>5，字符串,</h6><p>1，字符串在java中存储在字符串常量区中</p>
<p>2，==判断的是对象引用是否是同一个引用，判断字符串相等要用equals方法</p>
<p><strong>String类</strong></p>
<p>一，String对象是不可变的，每一个修改String值得方法，都是创建一个新的String对象</p>
<p>二，String做参数，传递的是String的引用</p>
<p>三，String具有只读性，任何引用都不能改变它的值</p>
<p>四，“+”操作符，对字符串进行连接，实际上每一次的连接都是创建一个新对象。再和下一个连接，很消耗内存，程序性能不好，所以就有了<code>StringBulider</code>类</p>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">replaceAll(<span class="string">"被替换的字符"</span>,<span class="string">""</span>):被替换的字符使用的是正则表达式</span><br><span class="line">split(String string) ：分割字符串</span><br><span class="line">substring(<span class="keyword">int</span> n):分割出索引之后的全部字符串部分</span><br><span class="line">subString(<span class="keyword">int</span> start,<span class="keyword">int</span> end):分割部分字符串</span><br></pre></td></tr></table></figure>



<p><strong>Pattern类和Marcher对象</strong></p>
<p>在JDK 1.4中，Java增加了对正则表达式的支持</p>
<p>java与正则相关的工具主要在<code>java.util.regex</code>包中；此包中主要有两个类：Pattern、Matcher</p>
<p>​                                                        </p>
<p><strong><code>StringBuffer类</code></strong></p>
<p>当对字符串进行修改的时候，需要使用 <code>StringBuffer</code> 和 <code>StringBuilder</code> 类</p>
<p>和 <code>String</code> 类不同的是，<code>StringBuffer</code> 和 <code>StringBuilder</code> 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p><code>StringBuilder</code> 类在 Java 5 中被提出，它和 <code>StringBuffer</code> 之间的最大不同在于 <code>StringBuilder</code> 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 <code>StringBuilder</code> 相较于 <code>StringBuffer</code> 有速度优势，所以多数情况下建议使用 <code>StringBuilder</code> 类。</p>
<p>然而在应用程序要求线程安全的情况下，则必须使用 <code>StringBuffer</code> 类。</p>
<p><strong><code>StringBulider类</code></strong></p>
<p>一，不论进行几次修改，都只是创建一个<code>StringBulider</code>对象</p>
<p>二，<code>StringBulider</code>就是基于String不可变的特点出来的</p>
<p>三，显示的创建<code>StringBulider</code>还可以预先指定大小，避免措辞重新分配缓存</p>
<p>四，<code>StringBulider</code>常用方法</p>
<p><strong>三个类的比较</strong></p>
<p><strong>一，性能</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StringBuilder &gt; StringBuffer &gt; String</span><br></pre></td></tr></table></figure>

<p><strong>二，何时使用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String适用于少量的字符串操作的情况</span><br><span class="line"></span><br><span class="line">StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况 </span><br><span class="line"></span><br><span class="line">StringBuffer适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure>

<p><strong><code>toSting</code>方法</strong></p>
<p>一，将<code>StringBuffer</code>对象和<code>StringBulider</code>对象转换为String对象</p>
<p><strong>正则表达式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">待做</span><br></pre></td></tr></table></figure>

<h6 id="6，boolean"><a href="#6，boolean" class="headerlink" title="6，boolean"></a>6，<code>boolean</code></h6><p>7，数据类型的初始值</p>
<p><img src="/.com//E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CqqA18D73086F0D435363C26D86B8CAD5E6%5C85c92a00f6234b30add5c47cc6e5cd56%5Cz2xc7zsr.bmp" alt="img"></p>
<p>附加：String的初始值是null，局部变量没有默认值</p>
<h3 id="二，转移字符"><a href="#二，转移字符" class="headerlink" title="二，转移字符"></a>二，转移字符</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格</td>
<td>\u0008</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
<td>\u0009</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>双引号</td>
<td></td>
<td>\u0022</td>
</tr>
<tr>
<td>单引号</td>
<td></td>
<td>\u0027</td>
</tr>
<tr>
<td>反斜杠</td>
<td></td>
<td>\u005c</td>
</tr>
</tbody></table>
<h3 id="三，变量"><a href="#三，变量" class="headerlink" title="三，变量"></a>三，变量</h3><p>变量命名规则：必须为合法的标识符,变量名必须是一个以字母开头，并且由字母或数字组成的序列</p>
<blockquote>
<p>标识符由任意的字母，下划线，美元符号，数字组成，并且第一个不能为数字，也不能用关键字</p>
<p>不建议使用美元符</p>
</blockquote>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>1，定义在类中，方法体外的变量</p>
<p>2，也称为对象变量，即没有加static的变量，在创建对象的时候就实例化了</p>
<p>成员变量（归属于实例变量）</p>
<p>1，可以被整个类访问，以及方法，构造方法，特定类的语句块</p>
<p>2，成员变量有默认值，即在分配了内存空间后所有成员变量会初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>1，在<strong>方法、构造方法或者语句块中定义的变量</strong>被称为局部变量</p>
<p>2，<strong>方法结束后，变量就会自动销毁</strong></p>
<p>3， 用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，<strong>所以局部变量要初始化</strong></p>
<h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>1，独立于方法之外的变量，<strong>用 static 修饰</strong>，类变量也叫<strong>静态变量</strong></p>
<p>2，<strong>静态方法只能访问静态成员变量</strong></p>
<p>3，<strong>静态成员可以被该类所有方法访问</strong></p>
<h4 id="final变量"><a href="#final变量" class="headerlink" title="final变量"></a>final变量</h4><p>1，用final修饰的变量</p>
<p>2，如果是<strong>基本数据类型的变量</strong>，则其数值<strong>一旦在初始化之后便不能更改</strong>；</p>
<p>3，如果是<strong>引用类型的变量</strong>，则在对其<strong>初始化之后便不能再让其指向另一个对象</strong></p>
<p>final方法</p>
<p>1，声明 final 方法的主要目的是<strong>防止该方法的内容被修改</strong>，类中的 final 方法可<strong>以被子类继承，但是不能被子类修改</strong></p>
<p>额外知识点</p>
<blockquote>
<p>堆区：只存放类对象（类中的成员变量），线程共享；</p>
<p>方法区：又叫静态存储区，存放class文件和静态数据，线程共享;</p>
<p>栈区：存放方法局部变量，基本类型变量区、执行环境上下文、操作指令区，线程不共享;       </p>
</blockquote>
<blockquote>
<p>final不能修饰抽象类，修饰的类可以被重载不能重写</p>
</blockquote>
<h3 id="四，常量"><a href="#四，常量" class="headerlink" title="四，常量"></a>四，常量</h3><p>1，使用关键字final指示</p>
<p>2，常量通常用大写</p>
<p>3，不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了</p>
<p>常量分为编译期常量和非编译期常量</p>
<p>​    编译期常量：在程序编译阶段【不需要加载类的字节码】，就可以确定常量的值</p>
<p>​    非编译期常量：在程序运行阶段【需要加载类的字节码】，可以确定常量的值</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">0</span>;<span class="comment">//编译期常量，不需要类加载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer d = <span class="keyword">new</span> Integer(<span class="number">2</span>);<span class="comment">//非编译期常量，需要类加载，报错！！</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="五，数值间的转换次序"><a href="#五，数值间的转换次序" class="headerlink" title="五，数值间的转换次序"></a>五，<strong>数值间的转换次序</strong></h3><p> <strong>规则</strong>：不是基本数据类型可以任意转换，<strong>占位少的可以转换为占位多的(自动)</strong>，占位多的需要通过强制类型转换，<strong>导致数据丢失</strong></p>
<p><strong>即</strong>：<strong><code>double</code>&gt;<code>float</code>&gt;<code>long</code>&gt;<code>int</code>&gt;<code>short</code>&gt;<code>char</code></strong></p>
<p><strong>信息丢失问题</strong></p>
<p>当两个不同类型的数进行基本运算符操作时，精度小的数值类型首先会向精度大的数值类型进行转换，超出的高位部分将被丢弃</p>
<p><strong>转换规则</strong></p>
<p>1.类型范围小的转换为大的</p>
<p>2.明确类型的表达式，会根据表达式的大小转换</p>
<p>3.都是数字的，转换为范围大的</p>
<h3 id="六，流程控制"><a href="#六，流程控制" class="headerlink" title="六，流程控制"></a>六，流程控制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if……else</span><br><span class="line">while（）</span><br><span class="line">do……while（）</span><br><span class="line">switch（）</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1，switch语句后的控制表达式只能是<code>short</code>、<code>char</code>、<code>int</code>、<code>byte</code>整数类型和枚举类型，不能是<code>float</code>，<code>double</code>和<code>boolean</code>类型。</p>
<p>2，<strong>String类型是java7开始支持</strong></p>
<h3 id="八，循环"><a href="#八，循环" class="headerlink" title="八，循环"></a>八，循环</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for循环，for……each循环，while循环</span><br></pre></td></tr></table></figure>

<p><strong>执行顺序</strong>:</p>
<ol>
<li>初始化语句, 仅在循环开始前执行一次;</li>
<li>布亇表达式, 用于决定是否继续执行正文过程, 表达式中异常则结束循环;</li>
<li>正文过程, 如果过程中存在break, return或者异常, 循环结束(不会执行更新语句), 如果遇到continue, 则会执行更新语句后进入下一轮循环;</li>
<li>更新语句, 注意更新语句不做逻辑真假判断, 到这里一轮循环结束;</li>
<li>布亇表达式, 进入新一轮循环;</li>
</ol>
<h3 id="九，数组"><a href="#九，数组" class="headerlink" title="九，数组"></a>九，数组</h3><p>声明方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int data[];</span><br><span class="line">int[] data;</span><br></pre></td></tr></table></figure>

<p>数组的初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] a &#x3D; new int[5];</span><br><span class="line">int a[] &#x3D; new int[5];</span><br><span class="line">int a[][] &#x3D; new int[7][];</span><br><span class="line">int a &#x3D; new int[]&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>



<h3 id="十，运算符"><a href="#十，运算符" class="headerlink" title="十，运算符"></a>十，运算符</h3><p><strong>算术运算符</strong></p>
<table>
<thead>
<tr>
<th>/</th>
<th>取整数</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>取余数</td>
</tr>
<tr>
<td>+</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td></td>
</tr>
<tr>
<td>自增/自减</td>
<td>a++    :    运行完了后再加<br>++a ： 加完了后再运行</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：数据类型的转化</p>
<p>1.int类型+String类型：转化为String类型</p>
<p><strong>关系运算符</strong></p>
<p>==，!=，&gt;，&lt;，&gt;=，&lt;=</p>
<p><strong>位运算符</strong></p>
<p>位运算符的运算是在二进制的基础上进行的</p>
<p>A=60    转化为二进制：0011 1100</p>
<p>B=13    转化为二进制：0000 1101</p>
<table>
<thead>
<tr>
<th>＆</th>
<th>如果相对应位都是1，则结果为1，否则为0</th>
<th>A＆B：12,即0000 1100</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>如果相对应位都是 0，则结果为 0，否则为 1</td>
<td>A | B：61,即 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>如果相对应位值相同，则结果为0，否则为1</td>
<td>A ^ B：49,即 0011 0001</td>
</tr>
<tr>
<td>〜</td>
<td>对二进制的每一位数进行翻转</td>
<td>〜A：-61,即1100 0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移运算符，向左移指定位数</td>
<td>A &lt;&lt; 2：240，即 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移运算符。向右移指定位数</td>
<td>A &gt;&gt; 2：15即 1111</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>按位右移补零操作符，移动得到的空位以零填充。</td>
<td>A&gt;&gt;&gt;2：15即0000 1111</td>
</tr>
</tbody></table>
<p> <strong>注意</strong>：当 <code>&amp;</code> 和 <code>|</code> 用于布尔值，得到的也是布尔值，在得到结果前，会计算两个操作数的值</p>
<p><strong>逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>&amp;&amp;</th>
<th></th>
<th>A &amp;&amp; B为假</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td></td>
<td>A  \ B为真</td>
</tr>
<tr>
<td>！</td>
<td></td>
<td>A &amp;&amp; B为真</td>
</tr>
</tbody></table>
<p><strong>短路逻辑运算符</strong></p>
<p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了</p>
<p><strong>赋值运算符</strong></p>
<table>
<thead>
<tr>
<th>=</th>
<th></th>
<th>C = A + B将把A + B得到的值赋给C</th>
</tr>
</thead>
<tbody><tr>
<td>+ =</td>
<td></td>
<td>C + = A等价于C = C + A</td>
</tr>
<tr>
<td>- =</td>
<td></td>
<td>C - = A等价于C = C - A</td>
</tr>
<tr>
<td>* =</td>
<td></td>
<td>C * = A等价于C = C * A</td>
</tr>
<tr>
<td>/ =</td>
<td></td>
<td>C / = A，C 与 A 同类型时等价于 C = C / A</td>
</tr>
<tr>
<td>（％）=</td>
<td></td>
<td>C％= A等价于C = C％A</td>
</tr>
<tr>
<td>&lt;&lt; =</td>
<td>左移位赋值运算符</td>
<td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt; =</td>
<td>右移位赋值运算符</td>
<td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>＆=</td>
<td>按位与赋值运算符</td>
<td>C＆= 2等价于C = C＆2</td>
</tr>
<tr>
<td>^ =</td>
<td>按位异或赋值操作符</td>
<td>C ^ = 2等价于C = C ^ 2</td>
</tr>
<tr>
<td>| =</td>
<td>按位或赋值操作符</td>
<td>C | = 2等价于C = C | 2</td>
</tr>
</tbody></table>
<p><strong>条件运算符（?:）</strong></p>
<p>条件运算符也被称为三元运算符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">variable x = (expression) ? value <span class="keyword">if</span> <span class="keyword">true</span> : value <span class="keyword">if</span> <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！</strong></p>
<p>当三元操作遇到可以转换为数字的类型，会自动做类型提升</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object a = <span class="keyword">true</span> ? Interge(<span class="number">1</span>) : Double(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>实际上会自动转换为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object a = <span class="keyword">true</span> ? Double(<span class="number">1</span>) : Double(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>也就是输出 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1.0</span></span><br></pre></td></tr></table></figure>



<p><strong><code>instanceof</code> 运算符</strong></p>
<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"James"</span>; </span><br><span class="line"><span class="keyword">boolean</span> result = name <span class="keyword">instanceof</span> String;  <span class="comment">// 由于 name 是 String 类型，所以返回真</span></span><br></pre></td></tr></table></figure>



<p><strong>额外注意</strong>：<strong>Java运算符优先级</strong></p>
<ul>
<li>! &gt; ~ &gt; 二元运算 &gt;一元运算 </li>
<li>* &gt; / &gt;%</li>
<li>&lt;&lt;大于&gt;&gt;大于&gt;&gt;&gt;</li>
<li><code>&lt;</code> 大于 <code>&lt;=</code> 大于<code>&gt;</code> 大于 <code>&gt;=</code> 大于<code>instanceof</code></li>
</ul>
<h3 id="十一，递归"><a href="#十一，递归" class="headerlink" title="十一，递归"></a>十一，递归</h3><p>递归：指在当前方法内调用自己 </p>
<p>递归的分类: 递归分为两种，直接递归和间接递归</p>
<p> 直接递归称为方法自身调用自己</p>
<p> 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法</p>
<p> <strong>注意事项</strong>： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出</p>
<p> 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</p>
<p> 构造方法,禁止递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>



<h3 id="十二，权限修饰符"><a href="#十二，权限修饰符" class="headerlink" title="十二，权限修饰符"></a>十二，权限修饰符</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>类中</th>
<th>同一个包中</th>
<th>子类中</th>
<th>任何地方</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>protected</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td></td>
</tr>
<tr>
<td>default</td>
<td>YES</td>
<td>YES</td>
<td></td>
<td></td>
</tr>
<tr>
<td>private</td>
<td>YES</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>注意：</p>
<p>1，<strong>声明时没有写访问修饰符默认是default</strong>，<strong>default不能修饰变量</strong></p>
<h2 id="字符编码和字符集"><a href="#字符编码和字符集" class="headerlink" title="字符编码和字符集"></a>字符编码和字符集</h2><p><strong>字符编码</strong>（Character Encoding）: 就是一套自然语言的字符与二进制数之间的对应规则。</p>
<p>计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果</p>
<p>按照某种规则，将字符存储到计算机中，称为<strong>编码</strong></p>
<p>反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为<strong>解码</strong>。</p>
<p><strong>编码表</strong>：生活中文字和计算机中二进制的对应规则</p>
<p><strong>字符集</strong>：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</p>
<blockquote>
<p>常见字符集有ASCII字符集、GBK字符集、Unicode字符集</p>
<p>Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码</p>
</blockquote>
<p>String类的构造方法提供了把字节数组转换成字符的方法</p>
<p><code>public String(byte[] bytes)</code></p>
<p><code>public String(byte[] bytes, String charsetName)</code></p>
<p>同时提供了<code>public byte[] getBytes()</code>和<code>public byte[] getBytes(String charsetName)</code>方法来把字符串转换为字节数组，有参方法用来指定字符集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编码和解码要统一</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"我真的是个好人"</span>.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">String s = <span class="keyword">new</span> String(bytes, <span class="string">"utf-8"</span></span><br></pre></td></tr></table></figure>



<h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><h3 id="一，面向对象程序设计（OOP）"><a href="#一，面向对象程序设计（OOP）" class="headerlink" title="一，面向对象程序设计（OOP）"></a>一，面向对象程序设计（OOP）</h3><ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<p><strong>面向对象程序的特性：封装性，多态性，继承性，（抽象性)</strong></p>
<p><strong>面向对象的五大基本原则：单一职责原则，开放封闭原则，里氏替换原则，接口隔离原则，依赖倒置原则</strong></p>
<p><strong>面向对象的语言的优点</strong>：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</p>
<p><strong>缺点</strong>：性能比面向过程低 </p>
<p><strong>面向过程的语言优点</strong>：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源</p>
<p><strong>缺点</strong>：没有面向对象易维护、易复用、易扩展</p>
<p>JAVA语言的特点（在《java程序设计习题精编》）</p>
<p>1.简单性：</p>
<p>2.面向对象：</p>
<p>3.分布式：java程序能通过url打开或者访问网络上的对象，就像访问本地文件</p>
<p>4.健壮：强类型，异常处理，内存自动回收</p>
<p>5.安全性：java有一个安全防范机制</p>
<p>6.体系结构中立：Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性</p>
<p>7.可移植：java的基本数据类型与硬件平台无关</p>
<p>8.解释型：Java解释器可以在任何一只了解释器的机器上执行Java字节码</p>
<p>9.高性能：</p>
<p>10.多线程：</p>
<p>11.动态:</p>
<h3 id="二，类"><a href="#二，类" class="headerlink" title="二，类"></a>二，类</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1，类是构造对象的模板或蓝图，它描述一类对象的行为和状态。</p>
<p>2，创建对象的过程——是类的实例化</p>
<p>3，所有的类都是“Object类”的子类</p>
<h4 id="类的分类"><a href="#类的分类" class="headerlink" title="类的分类"></a>类的分类</h4><p>1，基本类和不可变类</p>
<p>2，基本类分为普通类，抽象类，接口</p>
<ul>
<li>普通类：使用 class 定义且不含有抽象方法的类</li>
<li>抽象类：使用 abstract class 定义的类，它可以含有或不含有抽象方法</li>
<li>接口：使用 interface 定义的类</li>
</ul>
<h4 id="类的三种关系"><a href="#类的三种关系" class="headerlink" title="类的三种关系"></a>类的三种关系</h4><p>依赖（uses-a）：一个类的方法操纵另一个类的方法，我们就说一个类依赖于另一个类</p>
<p>（尽可能的减少这种依赖关系的类——即减少类之间的耦合度）</p>
<p>聚合（has-a）：聚合关系意味着一个类的对象包含另一个类的对象</p>
<p>  聚合也可以称为“关联”，这种关系的标准符号不易区分</p>
<p>继承（is-a）：</p>
<p><strong>注意</strong>：</p>
<p>  1.并不是所有的类都具有面向对象特征</p>
<h3 id="三，对象"><a href="#三，对象" class="headerlink" title="三，对象"></a>三，对象</h3><p>封装——将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式</p>
<p>对象中的数据称为——实例域</p>
<p>操纵数据的过程称为——方法</p>
<h4 id="对象的三个主要特征"><a href="#对象的三个主要特征" class="headerlink" title="对象的三个主要特征"></a>对象的三个主要特征</h4><ul>
<li>对象的行为（是可调用的方法定义的）</li>
<li>对象的状态（保留着描述当前特征的信息，状态的改变必须通过调用方法实现）</li>
<li>对象标识</li>
</ul>
<h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>概念一：构造器，使用构造器构造新的实例，是一种特殊的方法，用来构造并初始化对象</p>
<p>创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字new来创建一个对象。</li>
<li><strong>初始化</strong>：使用new创建对象时，会调用构造方法初始化对象</li>
</ul>
<h3 id="四，方法"><a href="#四，方法" class="headerlink" title="四，方法"></a>四，方法</h3><p> 方法是用于操作对象以及存取他们的实例域</p>
<h4 id="解刨方法"><a href="#解刨方法" class="headerlink" title="解刨方法"></a>解刨方法</h4><p>方法的第一个参数为隐式参数，是出现在方法名前的类对象</p>
<p>方法的第二个参数是在括号中的数值，称为显式参数</p>
<p>在每一个方法中，关键字this表示隐式参数</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>每个类都有构造方法。</li>
<li>如果没有显式地为类定义构造方法（没有定义任何构造函数），Java编译器（JVM）将会为该类提供一个默认构造方法。</li>
</ul>
<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>不会被外部的其他类操作调用</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法是一种不能面向对象实施操作的方法，没有隐式参数，即没有this参数，没有实例域（因为不能操作对象），但是可以访问自身类中的静态域，也可以称为类方法</p>
<p>一般通过类名调用静态方法，可以使用对象调用静态方法（ 不推荐），但需要是该类的对象，通常在工具类中使用类调用静态方法</p>
<p>  <strong>使用静态方法的情况</strong>：</p>
<p>​    一个方法不需要访问对象的状态，所需要的参数都是显式参数提供</p>
<p>​    一个方法只需要访问类的静态域</p>
<h4 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h4><p>java总是采用按值调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">100</span>;</span><br><span class="line">        System.out.println(value);<span class="comment">//100</span></span><br><span class="line"></span><br><span class="line">        reset(value);</span><br><span class="line">        System.out.println(value);<span class="comment">//100</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>  <strong>概念</strong></p>
<p>  封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法</p>
<p>  封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问</p>
<p>  要访问该类的代码和数据，必须通过严格的接口控制</p>
<p>  封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段</p>
<p>  适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性</p>
<p><strong>实现Java封装的步骤：</strong></p>
<ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为private）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String name; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> age;   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> name;   </span><br><span class="line">&#125; <span class="comment">//以下是对外的公共访问，访问类中的私有属性   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.age = age;    </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.name = name;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用 <strong>this</strong> 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突</p>
<p><strong>条件</strong>：</p>
<p>1.一个私有的数据域</p>
<p>2.一个公共的域访问器方法（get方法）</p>
<p>3.一个公有的域更改器方法（set方法）</p>
<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="一，继承"><a href="#一，继承" class="headerlink" title="一，继承"></a>一，继承</h3><p> 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</p>
<blockquote>
<p>子类又被称为派生类</p>
<p>父类又被称为超类</p>
</blockquote>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p> 继承可以使用 <strong>extends</strong> 和 <strong>implements</strong> 这两个关键字来实现继承</p>
<p><strong>注意：</strong></p>
<p>继承关系之中，如果要实例化子类对象，会默认先调用父类构造，为父类之中的属性初始化，之后再调用子类构造，为子类之中的属性初始化</p>
<p>即：默认情况下，子类会找到父类之中的无参构造方法。</p>
<p>现在默认调用的是无参构造，而如果这个时候父类没有无参构造，则子类必须通过super()调用指定参数的构造方法</p>
<h4 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h4><p><img src="/.com//E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CqqA18D73086F0D435363C26D86B8CAD5E6%5Cb81695219f214116b773a0ee8c5831d7%5Cdfm4byfk.bmp" alt="img"></p>
<h4 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a>继承特性</h4><ul>
<li>子类拥有父类非 private 的属性、方法</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</li>
<li>子类可以用自己的方式实现父类的方法</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</li>
</ul>
<h4 id="super-与-this-关键字"><a href="#super-与-this-关键字" class="headerlink" title="super 与 this 关键字"></a>super 与 this 关键字</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123; b() &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extend</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.a();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>额外注意：</p>
<p>1，只要被子类重写的方法，不被super调用都是调用子类方法</p>
<p>2，<strong>super关键字必须在构造方法的第一行 ，子类构造函数第一行默认就是super()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> A().a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>  <span class="keyword">extends</span>  <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> B().a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出的是A B</span></span><br><span class="line"><span class="comment">//如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错</span></span><br></pre></td></tr></table></figure>

<p>3，final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写</p>
<h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><p>1.构造方法可以进行重载，但是参数列表必须不相同，不可以返回值和访问级别进行区分</p>
<p>2构造方法没有返回值</p>
<p>3.构造方法一定要与定义为public的类同名</p>
<p>4.构造方法不能被对象调用，只会创建对象，使用new关键字</p>
<h4 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h4><p>重载</p>
<p>表示同一个类中可以有</p>
<ul>
<li>名称相同</li>
<li>方法的参数列表各不相同（即参数个数和类型不同）                                                                                    </li>
</ul>
<p>注意</p>
<p>1 ，在使用重载的时候只能通过不同的参数样式</p>
<p>2 ，不能通过访问权限，返回类型，抛出的异常进行重载</p>
<p>3 ，方法的异常类型不会对重载造成影响</p>
<p>4 ，对于继承来说，如果父类的访问权限是private，那么就不能在子类中进行重载，定义的话，也是相当于在子类中增加了一个新的方法</p>
<p>5，方法的返回值与重载无关</p>
<p>重写                                                                                                                                                                                                                                                                                                                                                    </p>
<ul>
<li>参数相同</li>
<li>把父类中定义的那个完全相同的方法给覆盖了</li>
</ul>
<p>注意</p>
<p>1，如果父类的方法的类型的是<strong>private类型</strong>，那么，子类则<strong>不存在覆盖的限制</strong>，则相当于子类增加了一个全新的方法。</p>
<p>2，覆盖的方法的标志必须要和被覆盖的<strong>方法的标志完全匹配</strong>，才能达到覆盖的效果。</p>
<p>3，覆盖的方法的返回值必须和被覆盖方法的<strong>返回值一致</strong>。</p>
<p>4，覆盖的方法所抛出的异常必须和被覆盖方法的<strong>所抛出的异常一致</strong>，或者是其异常的子类。</p>
<p>5，子类的访问权限只能比父类大，不能比父类小。</p>
<h4 id="子类与父类的代码块的执行顺序"><a href="#子类与父类的代码块的执行顺序" class="headerlink" title="子类与父类的代码块的执行顺序"></a>子类与父类的代码块的执行顺序</h4><p>父类的静态-&gt;子类的静态-&gt;父类的非静态-&gt;父类的构造-&gt;子类的非静态-&gt;子类的构造</p>
<p><strong>类的加载顺序</strong></p>
<p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)</p>
<p>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )</p>
<p>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )</p>
<p>(4) 父类构造函数</p>
<p>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )</p>
<p>(6) 子类构造函数</p>
<h3 id="二，多态"><a href="#二，多态" class="headerlink" title="二，多态"></a>二，多态</h3><p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态的特征是表现出多种形态，具有多种实现方式。或者多态是具有表现多种形态的能力的特征。或者同一个实现接口，使用不同的实例而执行不同的操作。</p>
<p>作用:</p>
<p>  1，可以增强程序的可扩展性及可维护性，使代码更加简洁。</p>
<p>  2，不但能减少编码的工作量，也能大大提高程序的可维护性及可扩展性</p>
<h4 id="三个必要条件"><a href="#三个必要条件" class="headerlink" title="三个必要条件"></a>三个必要条件</h4><p>继承，重写，父类引用指向子类对象</p>
<p>当使用多态方式调用方法时，<strong>首先检查父类中是否有该方法</strong>，如果没有，则编译错误；如果有，再去调用子类的同名方法</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>方式一：重写</p>
<p>方式二：接口</p>
<p>方式三：抽象类和抽象方法</p>
<h4 id="抽象类（abstract）"><a href="#抽象类（abstract）" class="headerlink" title="抽象类（abstract）"></a>抽象类（abstract）</h4><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，<strong>并不是所有的类都是用来描绘对象的</strong>，如果<strong>一个类中没有包含足够的信息来描绘一个具体的对象</strong>，这样的类就是<strong>抽象类</strong>。</p>
<p>特点：</p>
<p>1，不能实例化对象</p>
<p>2，抽象类必须被继承</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p><strong>抽象方法只包含一个方法名，而没有方法体</strong></p>
<p>抽象方法没有定义，<strong>方法名后面直接跟一个分号</strong>，而不是花括号。</p>
<p>注意</p>
<ul>
<li><strong>如果一个类包含抽象方法，那么该类必须是抽象类</strong></li>
<li><strong>任何子类必须重写父类的抽象方法</strong>，<strong>或者声明自身为抽象类</strong></li>
<li><strong>不能被final修饰</strong></li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="一，定义"><a href="#一，定义" class="headerlink" title="一，定义"></a>一，定义</h3><p>Java序列化就是指把Java对象转换为字节序列的过程</p>
<p>Java反序列化就是指把字节序列恢复为Java对象的过程</p>
<blockquote>
<p>用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息</p>
<p>字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化，对象的数据<code>、</code>对象的类型<code>和</code>对象中存储的数据`信息，都可以用来在内存中创建对象</p>
</blockquote>
<p>一个对象要想序列化，必须满足两个<strong>条件</strong>:</p>
<p>一：该类必须实现<code>java.io.Serializable</code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</p>
<p>二：该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</p>
<h3 id="二，作用"><a href="#二，作用" class="headerlink" title="二，作用"></a>二，作用</h3><p>序列化</p>
<p>1，在传递和保存对象时.保证对象的完整性和可传递性</p>
<p>2，对象转换为有序字节流,以便在网络上传输或者保存在本地文件中</p>
<p>反序列化</p>
<p>1，根据字节流中保存的对象状态及描述信息，通过反序列化重建对象</p>
<p><strong>总结：</strong>序列化机制的核心作用就是对象状态的保存与重建</p>
<p><strong>例子：</strong></p>
<p><strong>1，</strong>json/xml的数据传递</p>
<p><strong>2，</strong>Serializable接口</p>
<p>Serializable是Java提供的序列化接口，是一个空接口，<strong>为对象提供标准的序列化与反序列化操作</strong></p>
<p><strong>实现方式</strong></p>
<p>①若Student类仅仅实现了<strong>Serializable接口</strong>，则可以按照以下方式进行序列化和反序列化。</p>
<blockquote>
<p><code>ObjectOutputStream</code>采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。     </p>
<p><code>ObjcetInputStream</code>采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。</p>
</blockquote>
<p>②若Student类仅仅实现了Serializable接口，并且还定义了<code>readObject(ObjectInputStream in)</code>和<code>writeObject(ObjectOutputSteam out)</code>，则采用以下方式进行序列化与反序列化。</p>
<blockquote>
<p><code>ObjectOutputStream</code>调用Student对象的<code>writeObject(ObjectOutputStream out)</code>的方法进行序列化。</p>
<p><code>ObjectInputStream</code>会调用Student对象的<code>readObject(ObjectInputStream in)</code>的方法进行反序列化。</p>
</blockquote>
<p>③若Student类实现了<code>Externalnalizable</code>接口，且Student类必须实现<code>readExternal(ObjectInput in)</code>和<code>writeExternal(ObjectOutput out)</code>方法，则按照以下方式进行序列化与反序列化</p>
<blockquote>
<p><code>ObjectOutputStream</code>调用Student对象的<code>writeExternal(ObjectOutput out))</code>的方法进行序列化。 </p>
<p><code>ObjectInputStream</code>会调用Student对象的<code>readExternal(ObjectInput in)</code>的方法进行反序列化。</p>
</blockquote>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>即定义在一个类的内部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1，可以定义非静态属性和方法，不可以定义static修饰的属性和方法，可以定义static final修饰的编译期变量，除非用static修饰这个内部类</p>
<blockquote>
<p>为什么不可以定义static修饰的属性和方法？</p>
<p>​    首先内部类是外部类的一个成员，只有当外部类初始化的时候，内部类才能初始化，静态变量属于类级别，在类加载的时候就初始化</p>
<p>​    但是可以使用 static final 修饰的常量，即编译期常量</p>
</blockquote>
<h3 id="一，成员内部类"><a href="#一，成员内部类" class="headerlink" title="一，成员内部类"></a>一，成员内部类</h3><p>1，可以无条件的访问外部类的所有成员属性和成员方法（包括private和静态成员）</p>
<p>方式：</p>
<p>1-直接写属性名，其实本质还是外部类.this.属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(aa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(外部类.<span class="keyword">this</span>.aa);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这种写法适用于当需要访问和外部类同名的成员时</span></span><br></pre></td></tr></table></figure>

<p>反编译后的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Outter.<span class="keyword">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2，外部类访问内部类时需要创建成员内部类对象做引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外部类.内部类 in &#x3D; new 外部类().new 内部类();</span><br></pre></td></tr></table></figure>

<p>3，内部类具有访问private，protected的权限</p>
<h3 id="二，局部内部类"><a href="#二，局部内部类" class="headerlink" title="二，局部内部类"></a>二，局部内部类</h3><p>定义：定义在方法中的内部类</p>
<p>1、内部类不能被public、private、static修饰；</p>
<p>2、在外部类中不能创建内部类的实例；</p>
<p>3、内部类访问包含他的方法中的变量必须有final修饰；</p>
<p>4、外部类不能访问局部内部类，只能在方法体中访问局部内部类，且访问必须在内部类定义之后。</p>
<blockquote>
<p>为什么必须有final修饰呢？</p>
</blockquote>
<p> 首先需要知道的一点是:内部类和外部类是处于同一个级别的,内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁.</p>
<p>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期</p>
<h3 id="三，匿名内部类"><a href="#三，匿名内部类" class="headerlink" title="三，匿名内部类"></a>三，匿名内部类</h3><p>1，唯一没有构造器的类</p>
<p>2，一般使用匿名内部类编写监听事件的代码</p>
<p>3，不能有访问修饰符和static修饰符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">O</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner().get();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        O o = <span class="keyword">new</span> O();</span><br><span class="line">        o.a(<span class="keyword">new</span> A());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="四，静态内部类"><a href="#四，静态内部类" class="headerlink" title="四，静态内部类"></a>四，静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ss</span></span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(aa);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>1，不需要依赖于外部类</p>
<p>2，不能使用外部类非static的成员和方法    </p>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>Java中的基本数据类型没有方法和属性，而包装类就是为了让这些拥有方法和属性</p>
<h3 id="一，分类"><a href="#一，分类" class="headerlink" title="一，分类"></a>一，分类</h3><p>每个基本数据类型都对应着一个包装类</p>
<h3 id="二，转换"><a href="#二，转换" class="headerlink" title="二，转换"></a>二，转换</h3><p>装箱：基本数据类型转换为包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Intager ii = i;</span><br><span class="line"><span class="comment">//手动装箱</span></span><br><span class="line">Intager ii = <span class="keyword">new</span> Intager(i);</span><br></pre></td></tr></table></figure>



<p>拆箱：包装类转换为基本数据类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intager i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> ii = i;</span><br><span class="line"><span class="comment">//手动拆箱</span></span><br><span class="line"><span class="keyword">int</span> ii=i.intValue();</span><br></pre></td></tr></table></figure>



<h3 id="三，常用的方法"><a href="#三，常用的方法" class="headerlink" title="三，常用的方法"></a>三，常用的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toString()<span class="comment">//将整型转换为字符串</span></span><br><span class="line">Integer.parseInt()<span class="comment">//将字符串转换为int类型</span></span><br><span class="line">valueOf()<span class="comment">//方法把字符串转换为包装类然后通过自动拆箱</span></span><br></pre></td></tr></table></figure>





<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="一，概念"><a href="#一，概念" class="headerlink" title="一，概念"></a>一，概念</h3><p><strong>事件</strong>：用户对组件的一个操作，称之为一个事件</p>
<p><strong>事件源：</strong>发生事件的组件就是事件源</p>
<p><strong>事件监听器（处理器）</strong>：监听并负责处理事件的方法</p>
<h3 id="二，执行顺序"><a href="#二，执行顺序" class="headerlink" title="二，执行顺序"></a>二，执行顺序</h3><p>1、给事件源注册监听器</p>
<p>2、事件被触发</p>
<p>3、组件产生一个相应的事件对象，并把此对象传递给与之关联的事件监听器</p>
<p>4、事件处理器执行相关的代码来处理该事件</p>
<h3 id="三，使用"><a href="#三，使用" class="headerlink" title="三，使用"></a>三，使用</h3><p>匿名监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<p>监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mylistener</span> <span class="keyword">implements</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent actionEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是监听器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">button.addActionListener(actionEvent -&gt; <span class="keyword">new</span> mylistener());</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> mylistener());</span><br></pre></td></tr></table></figure>



<h3 id="四，分类"><a href="#四，分类" class="headerlink" title="四，分类"></a>四，分类</h3><p>动作事件（<code>ActionEvent</code>）</p>
<p>接口：<code>ActionListener</code></p>
<p>焦点事件（<code>FocousEvent</code>）</p>
<p>接口：<code>FocusListener</code></p>
<p>键盘事件（<code>KeyEvent</code>）</p>
<p>接口：<code>KeyListener</code></p>
<p>鼠标事件</p>
<p>接口：<code>MouseListener</code></p>
<p>窗口事件</p>
<p>选项事件</p>
<p>表格模型事件</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终<strong>会导致JVM的非正常停止</strong></p>
<p><strong>注意</strong>：    </p>
<p>1.在Java等面向对象的编程语言中，<strong>异常本身是一个类</strong>，产生异常就是创建异常对象并抛出了一个异常对象</p>
<p>2.java处理异常的方式是中断处理</p>
<p>3.异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
<p>异常产生过程</p>
<ol>
<li>方法处发生异常</li>
<li>JVM会产生一个异常对象：包括异常的名称，内容，产生位置</li>
<li>JVM将异常发送给方法的调用者（调用者无法处理，又会向上一级发送异常对象，即JVM）</li>
<li>JVM接受到异常对象，打印对象信息，并终止程序</li>
</ol>
<p><img src="/.com//E:%5C%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5CqqA18D73086F0D435363C26D86B8CAD5E6%5Ca06541cd094646bb8347118bde642426%5C%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<h3 id="一，分类-1"><a href="#一，分类-1" class="headerlink" title="一，分类"></a>一，分类</h3><p><strong><code>Throwable</code>体系：</strong></p>
<p>异常的根类是<strong><code>Throwable</code></strong>，其下有两个子类：<strong>Error</strong>与<strong>Exception</strong></p>
<p><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免。</p>
<p><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的</p>
<h3 id="二，异常-Exception-的分类"><a href="#二，异常-Exception-的分类" class="headerlink" title="二，异常(Exception)的分类"></a>二，异常(Exception)的分类</h3><p><strong>编译时期异常</strong>:checked异常    </p>
<p>在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</p>
<p><strong>运行时期异常</strong>:runtime异常(非检查异常)</p>
<p>在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常3/0)</p>
<h3 id="三，异常处理"><a href="#三，异常处理" class="headerlink" title="三，异常处理"></a>三，异常处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<p><strong>抛出异常throw</strong></p>
<p><strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，<strong>并结束当前方法的执行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用格式：</span><br><span class="line">throw new 异常类名(参数)</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>如果产生了问题，我们就会throw将问题描述类即异常进行抛出，<strong>也就是将问题返回给该方法的调用者。</strong></p>
<p>那么对于调用者来说，有两种处理方法：</p>
<p>1，一种是进行捕获处理</p>
<p>2，另一种就是继续将问题声明出去，使用throws声明处理</p>
<p><strong>声明异常throws</strong></p>
<p>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的<strong>调用者</strong>来处理异常(抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">声明异常格式：</span><br><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>捕获异常try…catch</strong></p>
<ol>
<li><p>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</p>
</li>
<li><p>在方法中使用try-catch的语句块来处理异常。</p>
</li>
<li><p>catch和finally不能同时省略</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">捕获异常语法如下：</span><br><span class="line">try&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;catch(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     &#x2F;&#x2F;记录日志&#x2F;打印异常信息&#x2F;继续抛出异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>:</p>
<ul>
<li><p>这种异常处理方式，要求<strong>多个catch中的异常不能相同</strong>，并且若catch中的多个异常之间有子父类异常的关系，那么<strong>子类异常要求在上面的catch处理</strong>，<strong>父类异常在下面的catch处理</strong></p>
</li>
<li><p><strong>运行时异常</strong>被抛出可以不处理。即不捕获也不声明抛出</p>
</li>
<li><p><strong>如果finally有return语句,永远返回finally中的结果,避免该情况</strong></p>
</li>
</ul>
<p><strong>（如果try语句中有return，返回的是try语句中的返回值，并且不受catch其他语句影响返回值）</strong></p>
<ul>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常</p>
</li>
<li><p><strong>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常</strong>。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h3 id="四，自定义异常"><a href="#四，自定义异常" class="headerlink" title="四，自定义异常"></a>四，自定义异常</h3><ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">class MyException extends Exception&#123;</span><br><span class="line">&#x2F;&#x2F;定义有参构造方法</span><br><span class="line">    public RegistException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125; &#125;</span><br><span class="line">&#x2F;&#x2F;只继承Exception 类来创建的异常类是检查性异常类。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(exprl)&#123;</span><br><span class="line">    throw new MuException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h2><blockquote>
<p>不做讨论</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加标签云</title>
    <url>/2020/01/04/exo%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E4%BA%91/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>如何在菜单栏下添加标签云(next-7版本)</p>
<a id="more"></a>
<p>插件地址：<a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">hexo-tag-cloud</a></p>
<hr>
<p>其他的就按照插件地址安装即可</p>
<p>但是值得注意的是！</p>
<p>1.说明文档中写的是先去添加一个依赖，再去下载，我尝试过，反正我是下不来</p>
<p>2.我的步骤是：先输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-tag-cloud</span><br></pre></td></tr></table></figure>
<p>这个时候你就会发现你的依赖里面已经多了一个，说明install成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;hexo-tag-cloud&quot;: &quot;^2.1.1&quot;,</span><br></pre></td></tr></table></figure>
<p>接着你就可以按着说明文档去给不同的版本去配置</p>
<br>

<blockquote>
<p>这里的依赖是指”dependencies”: {}大括号中的内容</p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo的使用</category>
      </categories>
      <tags>
        <tag>标签云</tag>
      </tags>
  </entry>
  <entry>
    <title>用本地md文件发布博客</title>
    <url>/2020/01/04/%E6%9C%AC%E5%9C%B0md%E6%96%87%E4%BB%B6%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="如何将本地的md文件发布到HEXO上"><a href="#如何将本地的md文件发布到HEXO上" class="headerlink" title="如何将本地的md文件发布到HEXO上"></a>如何将本地的md文件发布到HEXO上</h2><a id="more"></a>

<p>第一步：将md文件复制到Hexo/source/_posts目录下</p>
<p>第二步：在md文件的最上方添加一下部分内容的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: &#x2F;&#x2F;文章的名称</span><br><span class="line">tags: &#x2F;&#x2F;文章的标签</span><br><span class="line">categories: &#x2F;&#x2F;文章的分类</span><br><span class="line">author: &#x2F;&#x2F; 文章的作者</span><br><span class="line">date:  &#x2F;&#x2F; 写文章的时间</span><br></pre></td></tr></table></figure>

<p>第三步：一套流水线,然后就可以看到效果了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo的使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis基础学习</title>
    <url>/2020/01/04/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Redis概念</li>
<li>Redis使用</li>
<li>数据结构</li>
<li>命令操作<a id="more"></a>

</li>
</ul>
<hr>
<h2 id="Redis概念"><a href="#Redis概念" class="headerlink" title="Redis概念"></a>Redis概念</h2><p>Redis（全称：Remote Dictionary Server 远程字典服务）</p>
<ul>
<li><p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ！</p>
</li>
<li><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p>
</li>
</ul>
<blockquote>
<p><strong>总结：Redis是一款高性能的NOSQL系列的非关系型数据库</strong></p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis通过提供多种键值数据类型，目前为止Redis支持的键值<strong>数据类型</strong>如下：</p>
<ol>
<li>字符串类型 string </li>
<li>哈希类型 hash </li>
<li>列表类型 list </li>
<li>集合类型 set </li>
<li>有序集合类型 sortedset</li>
</ol>
<h2 id="redis的应用场景"><a href="#redis的应用场景" class="headerlink" title="redis的应用场景"></a>redis的应用场景</h2><ul>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等） </li>
<li>聊天室的在线好友列表 任务队列（秒杀、抢购、12306等等） </li>
<li>应用排行榜 </li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒 ）</li>
<li>分布式集群架构中的session分离</li>
</ul>
<h2 id="什么是NOSQL？"><a href="#什么是NOSQL？" class="headerlink" title="什么是NOSQL？"></a>什么是NOSQL？</h2><p>NoSQL(NoSQL = Not Only SQL)，即“不仅仅是SQL”</p>
<p><strong>是一项全新的数据库理念，泛指非关系型的数据库</strong></p>
<blockquote>
<p>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站<br>特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，<br>暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展</p>
</blockquote>
<p><strong>NoSQL数据库的产生</strong>就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题</p>
<h3 id="NOSQL和关系型数据库比较"><a href="#NOSQL和关系型数据库比较" class="headerlink" title="NOSQL和关系型数据库比较"></a>NOSQL和关系型数据库比较</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li><strong>成本</strong>：nosql数据库基本都是开源软件，相比关系型数据库价格便宜(orille)</li>
<li><strong>查询速度</strong>：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库</li>
<li><strong>存储数据的格式</strong>：nosql的存储格式是key,value形式（<strong>键值对</strong>）、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型</li>
</ol>
<blockquote>
<p>NOSQL是基于键值对的，不需要经过SQL层的解析，所以性能非常高。</p>
</blockquote>
<ol start="4">
<li><strong>扩展性</strong>：关系型数据库有类似join这样的多表查询机制(<strong>严格的模式限制</strong>)的限制导致扩展很艰难</li>
</ol>
<blockquote>
<p>NOSQL可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li><strong>维护的工具和资料有限</strong>，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语</li>
<li><strong>不提供对sql的支持</strong>，MySQL中使用的标准语言是SQL；而NoSQL中缺乏标准的查询语言</li>
<li><strong>不提供关系型数据库对事务的处理</strong>，sql复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
</ol>
<hr>
<blockquote>
<p>以上是自己通过视频的理解，更多可以参考<br><a href="https://blog.csdn.net/allen_a/article/details/50611966" target="_blank" rel="noopener">MySQL数据库与NoSQL数据库的区别</a><br><a href="https://www.php.cn/mysql-tutorials-418148.html" target="_blank" rel="noopener">nosql与mysql的区别是什么</a></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>两者通常情况下是：使用关系型数据库的同时，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补</p>
<p><strong>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</strong></p>
<hr>
<h2 id="Redis的使用"><a href="#Redis的使用" class="headerlink" title="Redis的使用"></a>Redis的使用</h2><h3 id="1-建议中文网下载，国外的网站慢的很"><a href="#1-建议中文网下载，国外的网站慢的很" class="headerlink" title="1.建议中文网下载，国外的网站慢的很"></a>1.建议中文网下载，国外的网站慢的很</h3><p> <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">Redis中文网</a></p>
<h3 id="2-解压直接可以使用"><a href="#2-解压直接可以使用" class="headerlink" title="2.解压直接可以使用"></a>2.解压直接可以使用</h3><h3 id="3-目录介绍"><a href="#3-目录介绍" class="headerlink" title="3.目录介绍"></a>3.目录介绍</h3><blockquote>
<ul>
<li>redis.windows.conf：配置文件         </li>
<li>redis-cli.exe：redis的客户端         </li>
<li>redis-server.exe：redis服务器端</li>
<li>redis-benchmark：性能测试工具</li>
<li>redis-check-aof：修复有问题的AOF文件</li>
<li>redis-check-dump：修复有问题的dump.rdb文件</li>
<li>redis-sentinel：redis集群使用</li>
</ul>
</blockquote>
<hr>
<h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><h3 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型 string"></a>字符串类型 string</h3><ol>
<li>存储： set key value</li>
<li>获取： get key</li>
<li>删除： del key</li>
</ol>
<h3 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h3><ol>
<li><p>存储： hset key field value</p>
</li>
<li><p>获取：</p>
<ol>
<li>hget key field: 获取指定的field对应的值</li>
<li>hgetall key：获取所有的field和value</li>
</ol>
</li>
<li><p>删除： hdel key field</p>
</li>
</ol>
<h3 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h3><h3 id="list-可以添加一个元素到列表的头部（左边）或者尾部（右边）"><a href="#list-可以添加一个元素到列表的头部（左边）或者尾部（右边）" class="headerlink" title="list:可以添加一个元素到列表的头部（左边）或者尾部（右边）"></a>list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</h3><ol>
<li>添加：<ol>
<li>lpush key value: 将元素加入列表左表</li>
<li>rpush key value：将元素加入列表右边</li>
</ol>
</li>
<li>获取：lrange key start end ：范围获取</li>
<li>删除：<ol>
<li>lpop key： 删除列表最左边的元素，并将元素返回</li>
<li>rpop key： 删除列表最右边的元素，并将元素返回</li>
</ol>
</li>
</ol>
<h3 id="集合类型-set-：-不允许重复元素"><a href="#集合类型-set-：-不允许重复元素" class="headerlink" title="集合类型 set ： 不允许重复元素"></a>集合类型 set ： 不允许重复元素</h3><ol>
<li>存储：sadd key value</li>
<li>获取：smembers key:获取set集合中所有元素</li>
<li>删除：srem key value:删除set集合中的某个元素    </li>
</ol>
<h3 id="有序集合类型-sortedset：不允许重复元素，且元素有顺序"><a href="#有序集合类型-sortedset：不允许重复元素，且元素有顺序" class="headerlink" title="有序集合类型 sortedset：不允许重复元素，且元素有顺序"></a>有序集合类型 sortedset：不允许重复元素，且元素有顺序</h3><p>每个元素都会关联一个double类型的分数<br>redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ol>
<li>存储：zadd key score value</li>
<li>获取：zrange key start end [withscores]                </li>
<li>删除：zrem key value</li>
</ol>
<h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><pre><code>1. keys * : 查询所有的键
2. type key ： 获取键对应的value的类型
3. del key：删除指定的key value</code></pre>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo Admin 发布文章</title>
    <url>/2019/12/31/hello-world/</url>
    <content><![CDATA[<h3 id="Hexo-Admin"><a href="#Hexo-Admin" class="headerlink" title=" Hexo Admin"></a><center><font face="Cooper Black"> Hexo Admin</font></center></h3><a id="more"></a>

<center><font face="华文行楷">第一次尝试使用Hexo Admin发布文章，也是第一次在Hexo上面发布文章</font></center>

<br>

<h4 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a><center><font face="华文行楷">具体实现方式</font></center></h4><p><font face="华文行楷">一：在Hexo网站目录下，安装 Hexo Admin 插件</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin</span><br></pre></td></tr></table></figure>

<p><font face="华文行楷">二：启动服务</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><font face="华文行楷">三：访问网址</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;admin&#x2F;</span><br></pre></td></tr></table></figure>
<p><font face="华文行楷">四：在线编辑</font></p>
]]></content>
      <categories>
        <category>Hexo的使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitHub搭建博客</title>
    <url>/2019/01/06/Hexo+GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>简单阐述搭建过程，就是方便了解总的流程</p>
<a id="more"></a>

<p>更加详细的过程请访问：<a href="http://note.youdao.com/noteshare?id=8b60a4919ffac7fe249c05e0fe8fca68&sub=WEBaa2c821c2f7ec63ccb27eea9b17f5a78" target="_blank" rel="noopener">我的有道云笔记</a></p>
<p><strong>1. 安装Node.js</strong></p>
<p><strong>2.  安装GIT</strong></p>
<p><strong>3. 检查GIT是否安装成功</strong></p>
<p>在cmd中输入：git –version，查看是否会有班版本信息</p>
<p><strong>4. 安装HEXO</strong></p>
<p>注意：</p>
<p>在安装之前需要确保node.js和git安装完成<br>确保安装的两个版本要对应，强烈建议始终尽可能安装最新版本的Hexo和推荐的Node.js 版本</p>
<p><strong>5. Hexo 更新至最新版本</strong></p>
<p>命令如下（是下载的最新的就不用执行了，免得搞出冲突）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm update hexo -g</span><br></pre></td></tr></table></figure>


<p><strong>6. 安装：在两者完成后可以通过npm安装</strong></p>
<p><strong>7. 初始化</strong></p>
<p>在blog文件中创建一个hexo文件，在hexo文件夹中git bash<br>输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>若出现以下界面则安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO Start blogging with Hexo！</span><br></pre></td></tr></table></figure>

<p><strong>8. 生成静态页面</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>


<p>输入以下命令，启动服务<br>$ hexo server</p>
<p>登录 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 验证是否成功</p>
<p><strong>9. 将博客部署到Github Pages上</strong></p>
<p>简单来讲就是创建一个仓库：Your_user_name.github.io</p>
<p><strong>10. 配置ssh密钥</strong></p>
<ol>
<li><p>输入$ ssh-keygen -t rsa -C “邮箱地址”</p>
</li>
<li><p>然后就会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;涂涂&#x2F;.ssh&#x2F;id_rsa):</span><br></pre></td></tr></table></figure></li>
<li><p>直接按Enter进行默认存储，就会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Created directory &#39;&#39;.</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">&#x2F;&#x2F;这里是要求输入密码，其实不用什么密码，直接回车</span><br></pre></td></tr></table></figure>
</li>
<li><p>出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter same passphrase again:</span><br><span class="line">&#x2F;&#x2F;同样直接回车</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就会出现一堆代码</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in &#x2F;c&#x2F;Users&#x2F;涂涂&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;c&#x2F;Users&#x2F;涂涂&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:</span><br><span class="line">&#x2F;&#x2F;这是各种字母数字组成的字符串，尾部是邮箱</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">&#x2F;&#x2F;这是各种数字组成的字符串</span><br></pre></td></tr></table></figure>
<p>6.输入以下命令，将内容复制到粘贴板上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>
<p><strong>11. 在GitHub上添加公钥</strong></p>
<p><strong>12. 测试ssh密钥是否成功</strong></p>
<ol>
<li><p>在第一个创建的文件夹中Git Bash，输入<br>$ ssh -T <a href="mailto:git@github.com">git@github.com</a></p>
</li>
<li><p>会出现一堆字母</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</span><br></pre></td></tr></table></figure></li>
<li><p>输入yes会显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You&#39;ve successfully authenticated...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>13.配置个人信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;用户名&quot;</span><br><span class="line">$ git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>
<p><strong>14.在你的HEXO目录下，一顿</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>然后访问 “<a href="http://github的仓库名&quot;" target="_blank" rel="noopener">http://github的仓库名&quot;</a> 就可以看到你的网站了</p>
]]></content>
      <categories>
        <category>Hexo的使用</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年度报告</title>
    <url>/2019/01/05/2020/</url>
    <content><![CDATA[<h1 id="个人2019年年度报告"><a href="#个人2019年年度报告" class="headerlink" title="个人2019年年度报告"></a><center>个人2019年年度报告</center></h1><a id="more"></a>

<blockquote>
<p>2019年包括是大一的下学期和大二上学期，以及暑假</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习的路上总会遇到一些厉害的人，努力的人，他们的进步总是能激起我们这些后辈的热血，这几天搭建好了博客，欣赏了很多大佬的个人博客，看了很多他们自己的成长历程，每一次的进步，每一次的记录，让本身对于博客就有想法的我更想去通过博客来记录自己的成长历程，也让那些人去感受成长时我踩过的坑，好避而让之。</p>
<p>万事开头难，好的开端需要一个好的引导，想写下一篇年度总结，反思过往，看好未来</p>
<p>总结如下：</p>
<h2 id="没做过什么大事"><a href="#没做过什么大事" class="headerlink" title="没做过什么大事"></a><center>没做过什么大事</center></h2><p>对于学校里的专业课，基本上都没怎么细细的去听了，都是一边听一边做做其他的，不是自己要装逼，是对于这个很普通的二本学校，学的是有点慢，出于自己对于编程的兴趣，很早就把老师的进度甩到了后面。学校的java课，开了两个学期，这是最要命的。上学期学习基础，下学期就学学高级的部分，说是高级但是没有去深入。就在这样的一个无挑战的环境中，浑浑噩噩。记得我大一下个学期，王者不知道打了多少吧，说真的有点后悔</p>
<h2 id="探索的一年"><a href="#探索的一年" class="headerlink" title="探索的一年"></a><center>探索的一年</center></h2><p>为什么说是探索的一年呢？</p>
<p>可以说，学习java这门语言的时候都会有这样的想法，就是怎么去学啊，学完了这个然后去学哪个啊，学完了记不住怎么办啊，等等这些，我想，都应该会有这样类似的经历吧，很正常。</p>
<p>所以，这就是”探索的一年”的由来。</p>
<p>这一年，我研究了很多学习路线，虽说总的路线一致（都是学JAVA咯，滑稽），但是也有区别。总路线一致就是说，以JAVA为例吧，先走JAVA基础，然后JAVAWeb，然后就是JAVAEE，再有就是项目开发，其他不是java的东西穿插着学。说什么有区别呢？简单讲就是学习的过程，学习的顺序不一样。有的要你先学习这个，有的要你先学习那个，各有各的方法，那到底应该学习什么，我也是研究了很久。大一下学期的时候，感觉一学期都在干这个，那个时候刚刚接触java，上课下课还是蛮用心的，把老师讲的搞完后，就去做自己的，学学这个，学学那个，制定了一个方案后，又看了一些推文，又觉得这个方案不好，总之，就是迷惑的一学期吧，但是也有收获的，研究的范围广了，知道了哪个时候该学什么，那个技术应该着重去学，那个技术只需要了解，已经过时。经过了这样一个学期，在大二开始的时候，就有了明确的目标，自己学完了JAVAWEB的大部分内容和技术，准备寒假做项目巩固。有句话说的好，要想战胜敌人，就得去了解敌人。如何学好这门课，还得去多了解一下相关的信息，才能如鱼得水。</p>
<p>为什么如此研究学习很重要？关系到学完了后你对这个东西的理解，更远一点，学习一些复杂的东西前你有过基础，那么，复杂在你看来就不怎么复杂了。举个例子，你学了js，并且较为熟练的掌握，那么jq还会难到你嘛？相反，那就说不准了。。。</p>
<h2 id="获得的技能"><a href="#获得的技能" class="headerlink" title="获得的技能"></a><center>获得的技能</center></h2><ol>
<li>JAVASE</li>
<li>部分HTML</li>
<li>部分CSS</li>
<li>JS</li>
<li>BootStarp的使用</li>
<li>TomCat</li>
<li>Servlet</li>
<li>Session&amp;&amp;Cookie</li>
<li>JSP</li>
<li>MVC</li>
<li>EL&amp;&amp;JSTL语法</li>
<li>javaBean</li>
<li>Filter</li>
<li>Listener</li>
<li>JQ</li>
<li>Ajax</li>
<li>JSON</li>
<li>Redis</li>
</ol>
<h2 id="仰望2020"><a href="#仰望2020" class="headerlink" title="仰望2020"></a><center>仰望2020</center></h2><h3 id="1-寒假-amp-amp-大二需要完成的书籍"><a href="#1-寒假-amp-amp-大二需要完成的书籍" class="headerlink" title="1. 寒假&amp;&amp;大二需要完成的书籍"></a>1. 寒假&amp;&amp;大二需要完成的书籍</h3><ol>
<li>《Java核心技术1&amp;&amp;2》</li>
<li>《编程是想》</li>
<li>《深入理解JVM》</li>
<li>《算法》</li>
<li>《java并发编程的艺术》</li>
<li>《java多线程编程核心技术》</li>
<li>《Effective Java》</li>
</ol>
<h3 id="2-大二需要掌握的技术"><a href="#2-大二需要掌握的技术" class="headerlink" title="2. 大二需要掌握的技术"></a>2. 大二需要掌握的技术</h3><ol>
<li>Myatis</li>
<li>Spring</li>
<li>SpringMvc</li>
<li>Git</li>
<li>Spring Boot</li>
<li>Docker</li>
<li>Maven</li>
</ol>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>对于2020年，总体来讲，是去深入的了解JAVA，并且去接触一些流行框架，同时掌握一些算法</p>
<br>


<hr>
<center><font face="华文行楷" size="5">目标：阿里巴巴</font></center>]]></content>
      <categories>
        <category>年度报告</category>
      </categories>
      <tags>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis持久化</title>
    <url>/2019/01/03/Redis2/</url>
    <content><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a><center><font>Redis持久化</font></center></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>什么是持久化</li>
<li>为什么持久化</li>
<li>怎么样持久化<a id="more"></a>

</li>
</ul>
<h2 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h2><p>狭义的理解： “持久化”仅仅指把域对象永久保存到数据库中；</p>
<p>广义的理解：“持久化”包括和数据库相关的各种操作</p>
<blockquote>
<p>总结：持久化就是将数据保存起来,某段时间再次使用<br>数据库技术,将内存数据一文件的形式保存在永久介质中(磁盘等)都是持久化的例子</p>
</blockquote>
<h2 id="为什么持久化"><a href="#为什么持久化" class="headerlink" title="为什么持久化"></a>为什么持久化</h2><p>个人认为就是能方便的拿数据，增加执行速度</p>
<p><strong>而Redis为什么要持久化呢？</strong></p>
<p>我的上篇文章讲了<a href="https://blog.csdn.net/Li_Tu/article/details/103818168" target="_blank" rel="noopener">Redis基础</a>，redis是一个内存数据库</p>
<p>当redis服务器重启，获取电脑重启，数据会丢失，所以我们要将redis内存中的数据持久化保存到硬盘的文件中</p>
<h2 id="Redis如何持久化"><a href="#Redis如何持久化" class="headerlink" title="Redis如何持久化"></a>Redis如何持久化</h2><p><strong>Redis持久化机制</strong></p>
<p><strong>RDB</strong>：默认方式，不需要进行配置，默认就使用这种机制</p>
<blockquote>
<p>即：在一定的间隔时间中，检测key的变化情况，然后持久化数据</p>
</blockquote>
<p>使用：</p>
<p>重新启动redis服务器，在Ridis文件目录下运行CMD指令输入：<br><code>redis-server.exe redis.windows.conf</code>    </p>
<p>解释说明：</p>
<p>1.在redis.windwos.conf文件，有以下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60  10000</span><br></pre></td></tr></table></figure>
<p> 2.而在这个内容的上方有这样的一段说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//<span class="string">"3种情况下会进行持久化操作"</span></span><br><span class="line">In the example below the behaviour will be to save:</span><br><span class="line">after 900 sec (15 min) <span class="keyword">if</span> at least 1 key changed</span><br><span class="line"><span class="string">"15分钟内1个键值改变"</span></span><br><span class="line">after 300 sec (5 min) <span class="keyword">if</span> at least 10 keys changed</span><br><span class="line"><span class="string">"5分钟内内至少10个键值改变"</span></span><br><span class="line">after 60 sec <span class="keyword">if</span> at least 10000 keys changed</span><br><span class="line"><span class="string">"60秒内至少10000个键值改变"</span></span><br></pre></td></tr></table></figure>
<p>3.根据自己的需求可以对上述的数字进行修改</p>
<hr>
<p><strong>AOF</strong>：日志记录的方式，每一次命令操作后，持久化数据</p>
<p>使用：</p>
<p>1.编辑redis.windwos.conf文件，找到以下内容<br><code>appendonly no</code></p>
<p>2.将no改成yes，即使用了AOF</p>
<p>3.找到以下内容，使用哪种方式就将前面的#去掉，只保留一个#</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;每一次操作都进行持久化&quot;</span><br><span class="line"># appendfsync always</span><br><span class="line">&quot;每隔一秒进行一次持久化&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">&quot;不进行持久化&quot;</span><br><span class="line"># appendfsync no</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
